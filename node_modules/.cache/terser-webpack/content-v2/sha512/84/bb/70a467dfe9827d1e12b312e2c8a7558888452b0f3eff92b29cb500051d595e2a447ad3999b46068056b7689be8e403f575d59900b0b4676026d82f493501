{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{tmjD:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return MaskDirective}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return NgxMaskModule});var _angular_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"fXoL\"),tslib__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"mrSG\"),_angular_forms__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"3Pt+\"),_angular_common__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"ofXK\");const config=new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r(\"config\"),NEW_CONFIG=new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r(\"NEW_CONFIG\"),INITIAL_CONFIG=new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r(\"INITIAL_CONFIG\"),initialConfig={suffix:\"\",prefix:\"\",thousandSeparator:\" \",decimalMarker:\".\",clearIfNotMatch:!1,showTemplate:!1,showMaskTyped:!1,placeHolderCharacter:\"_\",dropSpecialCharacters:!0,hiddenInput:void 0,shownMaskExpression:\"\",separatorLimit:\"\",allowNegativeNumbers:!1,validation:!0,specialCharacters:[\"-\",\"/\",\"(\",\")\",\".\",\":\",\" \",\"+\",\",\",\"@\",\"[\",\"]\",'\"',\"'\"],leadZeroDateTime:!1,patterns:{0:{pattern:new RegExp(\"\\\\d\")},9:{pattern:new RegExp(\"\\\\d\"),optional:!0},X:{pattern:new RegExp(\"\\\\d\"),symbol:\"*\"},A:{pattern:new RegExp(\"[a-zA-Z0-9]\")},S:{pattern:new RegExp(\"[a-zA-Z]\")},d:{pattern:new RegExp(\"\\\\d\")},m:{pattern:new RegExp(\"\\\\d\")},M:{pattern:new RegExp(\"\\\\d\")},H:{pattern:new RegExp(\"\\\\d\")},h:{pattern:new RegExp(\"\\\\d\")},s:{pattern:new RegExp(\"\\\\d\")}}},timeMasks=[\"Hh:m0:s0\",\"Hh:m0\",\"m0:s0\"],withoutValidation=[\"percent\",\"Hh\",\"s0\",\"m0\",\"separator\",\"d0/M0/0000\",\"d0/M0\",\"d0\",\"M0\"];let MaskApplierService=(()=>{class MaskApplierService{constructor(_config){this._config=_config,this.maskExpression=\"\",this.actualValue=\"\",this.shownMaskExpression=\"\",this._formatWithSeparators=(str,thousandSeparatorChar,decimalChar,precision)=>{const x=str.split(decimalChar),decimals=x.length>1?`${decimalChar}${x[1]}`:\"\";let res=x[0];const separatorLimit=this.separatorLimit.replace(/\\s/g,\"\");separatorLimit&&+separatorLimit&&(res=\"-\"===res[0]?\"-\"+res.slice(1,res.length).slice(0,separatorLimit.length):res.slice(0,separatorLimit.length));const rgx=/(\\d+)(\\d{3})/;for(;thousandSeparatorChar&&rgx.test(res);)res=res.replace(rgx,\"$1\"+thousandSeparatorChar+\"$2\");return void 0===precision?res+decimals:0===precision?res:res+decimals.substr(0,precision+1)},this.percentage=str=>Number(str)>=0&&Number(str)<=100,this.getPrecision=maskExpression=>{const x=maskExpression.split(\".\");return x.length>1?Number(x[x.length-1]):1/0},this.checkAndRemoveSuffix=inputValue=>{var _a,_b,_c;for(let i=(null===(_a=this.suffix)||void 0===_a?void 0:_a.length)-1;i>=0;i--){const substr=this.suffix.substr(i,null===(_b=this.suffix)||void 0===_b?void 0:_b.length);if(inputValue.includes(substr)&&(i-1<0||!inputValue.includes(this.suffix.substr(i-1,null===(_c=this.suffix)||void 0===_c?void 0:_c.length))))return inputValue.replace(substr,\"\")}return inputValue},this.checkInputPrecision=(inputValue,precision,decimalMarker)=>{if(precision<1/0){const precisionRegEx=new RegExp(this._charToRegExpExpression(decimalMarker)+`\\\\d{${precision}}.*$`),precisionMatch=inputValue.match(precisionRegEx);precisionMatch&&precisionMatch[0].length-1>precision&&(inputValue=inputValue.substring(0,inputValue.length-(precisionMatch[0].length-1-precision))),0===precision&&inputValue.endsWith(decimalMarker)&&(inputValue=inputValue.substring(0,inputValue.length-1))}return inputValue},this._shift=new Set,this.clearIfNotMatch=this._config.clearIfNotMatch,this.dropSpecialCharacters=this._config.dropSpecialCharacters,this.maskSpecialCharacters=this._config.specialCharacters,this.maskAvailablePatterns=this._config.patterns,this.prefix=this._config.prefix,this.suffix=this._config.suffix,this.thousandSeparator=this._config.thousandSeparator,this.decimalMarker=this._config.decimalMarker,this.hiddenInput=this._config.hiddenInput,this.showMaskTyped=this._config.showMaskTyped,this.placeHolderCharacter=this._config.placeHolderCharacter,this.validation=this._config.validation,this.separatorLimit=this._config.separatorLimit,this.allowNegativeNumbers=this._config.allowNegativeNumbers,this.leadZeroDateTime=this._config.leadZeroDateTime}applyMaskWithPattern(inputValue,maskAndPattern){const[mask,customPattern]=maskAndPattern;return this.customPattern=customPattern,this.applyMask(inputValue,mask)}applyMask(inputValue,maskExpression,position=0,justPasted=!1,backspaced=!1,cb=(()=>{})){if(null==inputValue||void 0===maskExpression)return\"\";let cursor=0,result=\"\",multi=!1,backspaceShift=!1,shift=1,stepBack=!1;inputValue.slice(0,this.prefix.length)===this.prefix&&(inputValue=inputValue.slice(this.prefix.length,inputValue.length)),this.suffix&&(null==inputValue?void 0:inputValue.length)>0&&(inputValue=this.checkAndRemoveSuffix(inputValue));const inputArray=inputValue.toString().split(\"\");\"IP\"===maskExpression&&(this.ipError=!!(inputArray.filter(i=>\".\"===i).length<3&&inputArray.length<7),maskExpression=\"099.099.099.099\");const arr=[];for(let i=0;i<inputValue.length;i++)inputValue[i].match(\"\\\\d\")&&arr.push(inputValue[i]);if(\"CPF_CNPJ\"===maskExpression&&(this.cpfCnpjError=!(11===arr.length||14===arr.length),maskExpression=arr.length>11?\"00.000.000/0000-00\":\"000.000.000-00\"),maskExpression.startsWith(\"percent\")){if(inputValue.match(\"[a-z]|[A-Z]\")||inputValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/)){inputValue=this._stripToDecimal(inputValue);const precision=this.getPrecision(maskExpression);inputValue=this.checkInputPrecision(inputValue,precision,this.decimalMarker)}if(inputValue.indexOf(\".\")>0&&!this.percentage(inputValue.substring(0,inputValue.indexOf(\".\")))){const base=inputValue.substring(0,inputValue.indexOf(\".\")-1);inputValue=`${base}${inputValue.substring(inputValue.indexOf(\".\"),inputValue.length)}`}result=this.percentage(inputValue)?inputValue:inputValue.substring(0,inputValue.length-1)}else if(maskExpression.startsWith(\"separator\")){(inputValue.match(\"[wа-яА-Я]\")||inputValue.match(\"[ЁёА-я]\")||inputValue.match(\"[a-z]|[A-Z]\")||inputValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\[\\]:\";<>.?\\/]/)||inputValue.match(\"[^A-Za-z0-9,]\"))&&(inputValue=this._stripToDecimal(inputValue)),inputValue=inputValue.length>1&&\"0\"===inputValue[0]&&inputValue[1]!==this.decimalMarker?inputValue.slice(1,inputValue.length):inputValue;const thousandSeperatorCharEscaped=this._charToRegExpExpression(this.thousandSeparator),decimalMarkerEscaped=this._charToRegExpExpression(this.decimalMarker),invalidChars='@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'.replace(thousandSeperatorCharEscaped,\"\").replace(decimalMarkerEscaped,\"\"),invalidCharRegexp=new RegExp(\"[\"+invalidChars+\"]\");inputValue.match(invalidCharRegexp)&&(inputValue=inputValue.substring(0,inputValue.length-1));const precision=this.getPrecision(maskExpression),strForSep=(inputValue=this.checkInputPrecision(inputValue,precision,this.decimalMarker)).replace(new RegExp(thousandSeperatorCharEscaped,\"g\"),\"\");result=this._formatWithSeparators(strForSep,this.thousandSeparator,this.decimalMarker,precision);const commaShift=result.indexOf(\",\")-inputValue.indexOf(\",\"),shiftStep=result.length-inputValue.length;if(shiftStep>0&&\",\"!==result[position]){backspaceShift=!0;let _shift=0;do{this._shift.add(position+_shift),_shift++}while(_shift<shiftStep)}else 0!==commaShift&&position>0&&!(result.indexOf(\",\")>=position&&position>3)||!(result.indexOf(\".\")>=position&&position>3)&&shiftStep<=0?(this._shift.clear(),backspaceShift=!0,shift=shiftStep,this._shift.add(position+=shiftStep)):this._shift.clear()}else for(let i=0,inputSymbol=inputArray[0];i<inputArray.length&&cursor!==maskExpression.length;i++,inputSymbol=inputArray[i])if(this._checkSymbolMask(inputSymbol,maskExpression[cursor])&&\"?\"===maskExpression[cursor+1])result+=inputSymbol,cursor+=2;else if(\"*\"===maskExpression[cursor+1]&&multi&&this._checkSymbolMask(inputSymbol,maskExpression[cursor+2]))result+=inputSymbol,cursor+=3,multi=!1;else if(this._checkSymbolMask(inputSymbol,maskExpression[cursor])&&\"*\"===maskExpression[cursor+1])result+=inputSymbol,multi=!0;else if(\"?\"===maskExpression[cursor+1]&&this._checkSymbolMask(inputSymbol,maskExpression[cursor+2]))result+=inputSymbol,cursor+=3;else if(this._checkSymbolMask(inputSymbol,maskExpression[cursor])){if(\"H\"===maskExpression[cursor]&&Number(inputSymbol)>2){cursor+=1,this._shiftStep(maskExpression,cursor,inputArray.length),i--,this.leadZeroDateTime&&(result+=\"0\");continue}if(\"h\"===maskExpression[cursor]&&\"2\"===result&&Number(inputSymbol)>3){cursor+=1,i--;continue}if(\"m\"===maskExpression[cursor]&&Number(inputSymbol)>5){cursor+=1,this._shiftStep(maskExpression,cursor,inputArray.length),i--,this.leadZeroDateTime&&(result+=\"0\");continue}if(\"s\"===maskExpression[cursor]&&Number(inputSymbol)>5){cursor+=1,this._shiftStep(maskExpression,cursor,inputArray.length),i--,this.leadZeroDateTime&&(result+=\"0\");continue}const daysCount=31;if(\"d\"===maskExpression[cursor]&&(Number(inputSymbol)>3&&this.leadZeroDateTime||Number(inputValue.slice(cursor,cursor+2))>daysCount||\"/\"===inputValue[cursor+1])){cursor+=1,this._shiftStep(maskExpression,cursor,inputArray.length),i--,this.leadZeroDateTime&&(result+=\"0\");continue}if(\"M\"===maskExpression[cursor]){const monthsCount=12,withoutDays=0===cursor&&(Number(inputSymbol)>2||Number(inputValue.slice(cursor,cursor+2))>monthsCount||\"/\"===inputValue[cursor+1]),day1monthInput=inputValue.slice(cursor-3,cursor-1).includes(\"/\")&&(\"/\"===inputValue[cursor-2]&&Number(inputValue.slice(cursor-1,cursor+1))>monthsCount&&\"/\"!==inputValue[cursor]||\"/\"===inputValue[cursor]||\"/\"===inputValue[cursor-3]&&Number(inputValue.slice(cursor-2,cursor))>monthsCount&&\"/\"!==inputValue[cursor-1]||\"/\"===inputValue[cursor-1]),day2monthInput=Number(inputValue.slice(cursor-3,cursor-1))<=daysCount&&!inputValue.slice(cursor-3,cursor-1).includes(\"/\")&&\"/\"===inputValue[cursor-1]&&(Number(inputValue.slice(cursor,cursor+2))>monthsCount||\"/\"===inputValue[cursor+1]),day1monthPaste=Number(inputValue.slice(cursor-3,cursor-1))>daysCount&&!inputValue.slice(cursor-3,cursor-1).includes(\"/\")&&!inputValue.slice(cursor-2,cursor).includes(\"/\")&&Number(inputValue.slice(cursor-2,cursor))>monthsCount,day2monthPaste=Number(inputValue.slice(cursor-3,cursor-1))<=daysCount&&!inputValue.slice(cursor-3,cursor-1).includes(\"/\")&&\"/\"!==inputValue[cursor-1]&&Number(inputValue.slice(cursor-1,cursor+1))>monthsCount;if(Number(inputSymbol)>1&&this.leadZeroDateTime||withoutDays||day1monthInput||day2monthInput||day1monthPaste||day2monthPaste){cursor+=1,this._shiftStep(maskExpression,cursor,inputArray.length),i--,this.leadZeroDateTime&&(result+=\"0\");continue}}result+=inputSymbol,cursor++}else-1!==this.maskSpecialCharacters.indexOf(maskExpression[cursor])?(result+=maskExpression[cursor],cursor++,this._shiftStep(maskExpression,cursor,inputArray.length),i--):this.maskSpecialCharacters.indexOf(inputSymbol)>-1&&this.maskAvailablePatterns[maskExpression[cursor]]&&this.maskAvailablePatterns[maskExpression[cursor]].optional?(inputArray[cursor]&&\"099.099.099.099\"!==maskExpression&&\"000.000.000-00\"!==maskExpression&&\"00.000.000/0000-00\"!==maskExpression&&(result+=inputArray[cursor]),cursor++,i--):\"*\"===this.maskExpression[cursor+1]&&this._findSpecialChar(this.maskExpression[cursor+2])&&this._findSpecialChar(inputSymbol)===this.maskExpression[cursor+2]&&multi||\"?\"===this.maskExpression[cursor+1]&&this._findSpecialChar(this.maskExpression[cursor+2])&&this._findSpecialChar(inputSymbol)===this.maskExpression[cursor+2]&&multi?(cursor+=3,result+=inputSymbol):this.showMaskTyped&&this.maskSpecialCharacters.indexOf(inputSymbol)<0&&inputSymbol!==this.placeHolderCharacter&&(stepBack=!0);result.length+1===maskExpression.length&&-1!==this.maskSpecialCharacters.indexOf(maskExpression[maskExpression.length-1])&&(result+=maskExpression[maskExpression.length-1]);let newPosition=position+1;for(;this._shift.has(newPosition);)shift++,newPosition++;let actualShift=justPasted?cursor:this._shift.has(position)?shift:0;stepBack&&actualShift--,cb(actualShift,backspaceShift),shift<0&&this._shift.clear();let onlySpecial=!1;backspaced&&(onlySpecial=inputArray.every(char=>this.maskSpecialCharacters.includes(char)));let res=`${this.prefix}${onlySpecial?\"\":result}${this.suffix}`;return 0===result.length&&(res=`${this.prefix}${result}`),res}_findSpecialChar(inputSymbol){return this.maskSpecialCharacters.find(val=>val===inputSymbol)}_checkSymbolMask(inputSymbol,maskSymbol){return this.maskAvailablePatterns=this.customPattern?this.customPattern:this.maskAvailablePatterns,this.maskAvailablePatterns[maskSymbol]&&this.maskAvailablePatterns[maskSymbol].pattern&&this.maskAvailablePatterns[maskSymbol].pattern.test(inputSymbol)}_stripToDecimal(str){return str.split(\"\").filter((i,idx)=>i.match(\"^-?\\\\d\")||i.match(\"\\\\s\")||\".\"===i||\",\"===i||\"-\"===i&&0===idx&&this.allowNegativeNumbers).join(\"\")}_charToRegExpExpression(char){if(char){const charsToEscape=\"[\\\\^$.|?*+()\";return\" \"===char?\"\\\\s\":charsToEscape.indexOf(char)>=0?\"\\\\\"+char:char}return char}_shiftStep(maskExpression,cursor,inputLength){const shiftStep=/[*?]/g.test(maskExpression.slice(0,cursor))?inputLength:cursor;this._shift.add(shiftStep+this.prefix.length||0)}}return MaskApplierService.ɵfac=function(t){return new(t||MaskApplierService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(config))},MaskApplierService.ɵprov=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb({token:MaskApplierService,factory:MaskApplierService.ɵfac}),MaskApplierService})(),MaskService=(()=>{class MaskService extends MaskApplierService{constructor(document,_config,_elementRef,_renderer){super(_config),this.document=document,this._config=_config,this._elementRef=_elementRef,this._renderer=_renderer,this.maskExpression=\"\",this.isNumberValue=!1,this.placeHolderCharacter=\"_\",this.maskIsShown=\"\",this.selStart=null,this.selEnd=null,this.writingValue=!1,this.onChange=_=>{}}applyMask(inputValue,maskExpression,position=0,justPasted=!1,backspaced=!1,cb=(()=>{})){if(!maskExpression)return inputValue;if(this.maskIsShown=this.showMaskTyped?this.showMaskInInput():\"\",\"IP\"===this.maskExpression&&this.showMaskTyped&&(this.maskIsShown=this.showMaskInInput(inputValue||\"#\")),\"CPF_CNPJ\"===this.maskExpression&&this.showMaskTyped&&(this.maskIsShown=this.showMaskInInput(inputValue||\"#\")),!inputValue&&this.showMaskTyped)return this.formControlResult(this.prefix),this.prefix+this.maskIsShown;const getSymbol=inputValue&&\"number\"==typeof this.selStart?inputValue[this.selStart]:\"\";let newInputValue=\"\";if(void 0!==this.hiddenInput){let actualResult=this.actualValue.split(\"\");\"\"!==inputValue&&actualResult.length?\"number\"==typeof this.selStart&&\"number\"==typeof this.selEnd&&(inputValue.length>actualResult.length?actualResult.splice(this.selStart,0,getSymbol):inputValue.length<actualResult.length&&(actualResult.length-inputValue.length==1?actualResult.splice(this.selStart-1,1):actualResult.splice(this.selStart,this.selEnd-this.selStart))):actualResult=[],newInputValue=this.actualValue.length?this.shiftTypedSymbols(actualResult.join(\"\")):inputValue}newInputValue=Boolean(newInputValue)&&newInputValue.length?newInputValue:inputValue;const result=super.applyMask(newInputValue,maskExpression,position,justPasted,backspaced,cb);if(this.actualValue=this.getActualValue(result),\".\"===this.thousandSeparator&&\".\"===this.decimalMarker&&(this.decimalMarker=\",\"),this.maskExpression.startsWith(\"separator\")&&!0===this.dropSpecialCharacters&&(this.maskSpecialCharacters=this.maskSpecialCharacters.filter(item=>item!==this.decimalMarker)),this.formControlResult(result),!this.showMaskTyped)return this.hiddenInput&&result&&result.length?this.hideInput(result,this.maskExpression):result;const resLen=result.length,prefNmask=this.prefix+this.maskIsShown;if(this.maskExpression.includes(\"H\")){const countSkipedSymbol=this._numberSkipedSymbols(result);return result+prefNmask.slice(resLen+countSkipedSymbol)}return\"IP\"===this.maskExpression||\"CPF_CNPJ\"===this.maskExpression?result+prefNmask:result+prefNmask.slice(resLen)}_numberSkipedSymbols(value){const regex=/(^|\\D)(\\d\\D)/g;let match=regex.exec(value),countSkipedSymbol=0;for(;null!=match;)countSkipedSymbol+=1,match=regex.exec(value);return countSkipedSymbol}applyValueChanges(position=0,justPasted,backspaced,cb=(()=>{})){const formElement=this._elementRef.nativeElement;formElement.value=this.applyMask(formElement.value,this.maskExpression,position,justPasted,backspaced,cb),formElement!==this.document.activeElement&&this.clearIfNotMatchFn()}hideInput(inputValue,maskExpression){return inputValue.split(\"\").map((curr,index)=>this.maskAvailablePatterns&&this.maskAvailablePatterns[maskExpression[index]]&&this.maskAvailablePatterns[maskExpression[index]].symbol?this.maskAvailablePatterns[maskExpression[index]].symbol:curr).join(\"\")}getActualValue(res){const compare=res.split(\"\").filter((symbol,i)=>this._checkSymbolMask(symbol,this.maskExpression[i])||this.maskSpecialCharacters.includes(this.maskExpression[i])&&symbol===this.maskExpression[i]);return compare.join(\"\")===res?compare.join(\"\"):res}shiftTypedSymbols(inputValue){let symbolToReplace=\"\";return(inputValue&&inputValue.split(\"\").map((currSymbol,index)=>{if(this.maskSpecialCharacters.includes(inputValue[index+1])&&inputValue[index+1]!==this.maskExpression[index+1])return symbolToReplace=currSymbol,inputValue[index+1];if(symbolToReplace.length){const replaceSymbol=symbolToReplace;return symbolToReplace=\"\",replaceSymbol}return currSymbol})||[]).join(\"\")}showMaskInInput(inputVal){if(this.showMaskTyped&&this.shownMaskExpression){if(this.maskExpression.length!==this.shownMaskExpression.length)throw new Error(\"Mask expression must match mask placeholder length\");return this.shownMaskExpression}if(this.showMaskTyped){if(inputVal){if(\"IP\"===this.maskExpression)return this._checkForIp(inputVal);if(\"CPF_CNPJ\"===this.maskExpression)return this._checkForCpfCnpj(inputVal)}return this.maskExpression.replace(/\\w/g,this.placeHolderCharacter)}return\"\"}clearIfNotMatchFn(){const formElement=this._elementRef.nativeElement;this.clearIfNotMatch&&this.prefix.length+this.maskExpression.length+this.suffix.length!==formElement.value.replace(/_/g,\"\").length&&(this.formElementProperty=[\"value\",\"\"],this.applyMask(formElement.value,this.maskExpression))}set formElementProperty([name,value]){Promise.resolve().then(()=>this._renderer.setProperty(this._elementRef.nativeElement,name,value))}checkSpecialCharAmount(mask){return mask.split(\"\").filter(item=>this._findSpecialChar(item)).length}removeMask(inputValue){return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)),this.maskSpecialCharacters.concat(\"_\").concat(this.placeHolderCharacter))}_checkForIp(inputVal){if(\"#\"===inputVal)return`${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;const arr=[];for(let i=0;i<inputVal.length;i++)inputVal[i].match(\"\\\\d\")&&arr.push(inputVal[i]);return arr.length<=3?`${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`:arr.length>3&&arr.length<=6?`${this.placeHolderCharacter}.${this.placeHolderCharacter}`:arr.length>6&&arr.length<=9?this.placeHolderCharacter:\"\"}_checkForCpfCnpj(inputVal){const cpf=`${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}-${this.placeHolderCharacter}${this.placeHolderCharacter}`,cnpj=`${this.placeHolderCharacter}${this.placeHolderCharacter}.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}-${this.placeHolderCharacter}${this.placeHolderCharacter}`;if(\"#\"===inputVal)return cpf;const arr=[];for(let i=0;i<inputVal.length;i++)inputVal[i].match(\"\\\\d\")&&arr.push(inputVal[i]);return arr.length<=3?cpf.slice(arr.length,cpf.length):arr.length>3&&arr.length<=6?cpf.slice(arr.length+1,cpf.length):arr.length>6&&arr.length<=9?cpf.slice(arr.length+2,cpf.length):arr.length>9&&arr.length<11?cpf.slice(arr.length+3,cpf.length):11===arr.length?\"\":12===arr.length?cnpj.slice(17===inputVal.length?16:15,cnpj.length):arr.length>12&&arr.length<=14?cnpj.slice(arr.length+4,cnpj.length):\"\"}formControlResult(inputValue){this.writingValue||(Array.isArray(this.dropSpecialCharacters)?this.onChange(this._toNumber(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)),this.dropSpecialCharacters))):this.onChange(this.dropSpecialCharacters?this._toNumber(this._checkSymbols(inputValue)):this._removeSuffix(inputValue)))}_toNumber(value){if(!this.isNumberValue)return value;const num=Number(value);return Number.isNaN(num)?value:num}_removeMask(value,specialCharactersForRemove){return value?value.replace(this._regExpForRemove(specialCharactersForRemove),\"\"):value}_removePrefix(value){return this.prefix&&value?value.replace(this.prefix,\"\"):value}_removeSuffix(value){return this.suffix&&value?value.replace(this.suffix,\"\"):value}_retrieveSeparatorValue(result){return this._removeMask(this._removeSuffix(this._removePrefix(result)),this.maskSpecialCharacters)}_regExpForRemove(specialCharactersForRemove){return new RegExp(specialCharactersForRemove.map(item=>\"\\\\\"+item).join(\"|\"),\"gi\")}_checkSymbols(result){if(\"\"===result)return result;const separatorPrecision=this._retrieveSeparatorPrecision(this.maskExpression);let separatorValue=this._retrieveSeparatorValue(result);return\".\"!==this.decimalMarker&&(separatorValue=separatorValue.replace(this.decimalMarker,\".\")),this.isNumberValue?separatorPrecision?result===this.decimalMarker?null:this._checkPrecision(this.maskExpression,separatorValue):Number(separatorValue):separatorValue}_retrieveSeparatorPrecision(maskExpretion){const matcher=maskExpretion.match(new RegExp(\"^separator\\\\.([^d]*)\"));return matcher?Number(matcher[1]):null}_checkPrecision(separatorExpression,separatorValue){return separatorExpression.indexOf(\"2\")>0?Number(separatorValue).toFixed(2):Number(separatorValue)}}return MaskService.ɵfac=function(t){return new(t||MaskService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(_angular_common__WEBPACK_IMPORTED_MODULE_3__.d),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(config),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.l),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.E))},MaskService.ɵprov=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb({token:MaskService,factory:MaskService.ɵfac}),MaskService})(),MaskDirective=(()=>{class MaskDirective{constructor(document,_maskService,_config){this.document=document,this._maskService=_maskService,this._config=_config,this.maskExpression=\"\",this.specialCharacters=[],this.patterns={},this.prefix=\"\",this.suffix=\"\",this.thousandSeparator=\" \",this.decimalMarker=\".\",this.dropSpecialCharacters=null,this.hiddenInput=null,this.showMaskTyped=null,this.placeHolderCharacter=null,this.shownMaskExpression=null,this.showTemplate=null,this.clearIfNotMatch=null,this.validation=null,this.separatorLimit=null,this.allowNegativeNumbers=null,this.leadZeroDateTime=null,this._maskValue=\"\",this._position=null,this._maskExpressionArray=[],this._justPasted=!1,this.onChange=_=>{},this.onTouch=()=>{}}ngOnChanges(changes){const{maskExpression:maskExpression,specialCharacters:specialCharacters,patterns:patterns,prefix:prefix,suffix:suffix,thousandSeparator:thousandSeparator,decimalMarker:decimalMarker,dropSpecialCharacters:dropSpecialCharacters,hiddenInput:hiddenInput,showMaskTyped:showMaskTyped,placeHolderCharacter:placeHolderCharacter,shownMaskExpression:shownMaskExpression,showTemplate:showTemplate,clearIfNotMatch:clearIfNotMatch,validation:validation,separatorLimit:separatorLimit,allowNegativeNumbers:allowNegativeNumbers,leadZeroDateTime:leadZeroDateTime}=changes;if(maskExpression&&(this._maskValue=maskExpression.currentValue||\"\",maskExpression.currentValue&&maskExpression.currentValue.split(\"||\").length>1&&(this._maskExpressionArray=maskExpression.currentValue.split(\"||\").sort((a,b)=>a.length-b.length),this._maskValue=this._maskExpressionArray[0],this.maskExpression=this._maskExpressionArray[0],this._maskService.maskExpression=this._maskExpressionArray[0])),specialCharacters){if(!specialCharacters.currentValue||!Array.isArray(specialCharacters.currentValue))return;this._maskService.maskSpecialCharacters=specialCharacters.currentValue||[]}patterns&&patterns.currentValue&&(this._maskService.maskAvailablePatterns=patterns.currentValue),prefix&&(this._maskService.prefix=prefix.currentValue),suffix&&(this._maskService.suffix=suffix.currentValue),thousandSeparator&&(this._maskService.thousandSeparator=thousandSeparator.currentValue),decimalMarker&&(this._maskService.decimalMarker=decimalMarker.currentValue),dropSpecialCharacters&&(this._maskService.dropSpecialCharacters=dropSpecialCharacters.currentValue),hiddenInput&&(this._maskService.hiddenInput=hiddenInput.currentValue),showMaskTyped&&(this._maskService.showMaskTyped=showMaskTyped.currentValue),placeHolderCharacter&&(this._maskService.placeHolderCharacter=placeHolderCharacter.currentValue),shownMaskExpression&&(this._maskService.shownMaskExpression=shownMaskExpression.currentValue),showTemplate&&(this._maskService.showTemplate=showTemplate.currentValue),clearIfNotMatch&&(this._maskService.clearIfNotMatch=clearIfNotMatch.currentValue),validation&&(this._maskService.validation=validation.currentValue),separatorLimit&&(this._maskService.separatorLimit=separatorLimit.currentValue),allowNegativeNumbers&&(this._maskService.allowNegativeNumbers=allowNegativeNumbers.currentValue,this._maskService.allowNegativeNumbers&&(this._maskService.maskSpecialCharacters=this._maskService.maskSpecialCharacters.filter(c=>\"-\"!==c))),leadZeroDateTime&&(this._maskService.leadZeroDateTime=leadZeroDateTime.currentValue),this._applyMask()}validate({value:value}){if(!this._maskService.validation||!this._maskValue)return null;if(this._maskService.ipError)return this._createValidationError(value);if(this._maskService.cpfCnpjError)return this._createValidationError(value);if(this._maskValue.startsWith(\"separator\"))return null;if(withoutValidation.includes(this._maskValue))return null;if(this._maskService.clearIfNotMatch)return null;if(timeMasks.includes(this._maskValue))return this._validateTime(value);if(value&&value.toString().length>=1){let counterOfOpt=0;for(const key in this._maskService.maskAvailablePatterns)if(this._maskService.maskAvailablePatterns[key].optional&&!0===this._maskService.maskAvailablePatterns[key].optional){if(this._maskValue.indexOf(key)!==this._maskValue.lastIndexOf(key)?counterOfOpt+=this._maskValue.split(\"\").filter(i=>i===key).join(\"\").length:-1!==this._maskValue.indexOf(key)&&counterOfOpt++,-1!==this._maskValue.indexOf(key)&&value.toString().length>=this._maskValue.indexOf(key))return null;if(counterOfOpt===this._maskValue.length)return null}if(1===this._maskValue.indexOf(\"{\")&&value.toString().length===this._maskValue.length+Number(this._maskValue.split(\"{\")[1].split(\"}\")[0])-4)return null;if(1===this._maskValue.indexOf(\"*\")||1===this._maskValue.indexOf(\"?\"))return null;if(this._maskValue.indexOf(\"*\")>1&&value.toString().length<this._maskValue.indexOf(\"*\")||this._maskValue.indexOf(\"?\")>1&&value.toString().length<this._maskValue.indexOf(\"?\")||1===this._maskValue.indexOf(\"{\"))return this._createValidationError(value);if(-1===this._maskValue.indexOf(\"*\")||-1===this._maskValue.indexOf(\"?\")){const length=this._maskService.dropSpecialCharacters?this._maskValue.length-this._maskService.checkSpecialCharAmount(this._maskValue)-counterOfOpt:this._maskValue.length-counterOfOpt;if(value.toString().length<length)return this._createValidationError(value)}}return null}onPaste(){this._justPasted=!0}onInput(e){const el=e.target;if(this._inputValue=el.value,this._setMask(),!this._maskValue)return void this.onChange(el.value);const position=1===el.selectionStart?el.selectionStart+this._maskService.prefix.length:el.selectionStart;let caretShift=0,backspaceShift=!1;if(this._maskService.applyValueChanges(position,this._justPasted,\"Backspace\"===this._code,(shift,_backspaceShift)=>{this._justPasted=!1,caretShift=shift,backspaceShift=_backspaceShift}),this.document.activeElement!==el)return;this._position=1===this._position&&1===this._inputValue.length?null:this._position;let positionToApply=this._position?this._inputValue.length+position+caretShift:position+(\"Backspace\"!==this._code||backspaceShift?caretShift:0);positionToApply>this._getActualInputLength()&&(positionToApply=this._getActualInputLength()),el.setSelectionRange(positionToApply,positionToApply),this._position=null}onBlur(){this._maskValue&&this._maskService.clearIfNotMatchFn(),this.onTouch()}onFocus(e){if(!this._maskValue)return;const el=e.target;null!==el&&null!==el.selectionStart&&el.selectionStart===el.selectionEnd&&el.selectionStart>this._maskService.prefix.length&&38!==e.keyCode&&this._maskService.showMaskTyped&&(this._maskService.maskIsShown=this._maskService.showMaskInInput(),el.setSelectionRange&&this._maskService.prefix+this._maskService.maskIsShown===el.value?(el.focus(),el.setSelectionRange(0,0)):el.selectionStart>this._maskService.actualValue.length&&el.setSelectionRange(this._maskService.actualValue.length,this._maskService.actualValue.length));const nextValue=el.value&&el.value!==this._maskService.prefix?el.value:this._maskService.prefix+this._maskService.maskIsShown;el.value!==nextValue&&(el.value=nextValue),(el.selectionStart||el.selectionEnd)<=this._maskService.prefix.length?el.selectionStart=this._maskService.prefix.length:el.selectionEnd>this._getActualInputLength()&&(el.selectionEnd=this._getActualInputLength())}onKeyDown(e){var _a;if(!this._maskValue)return;this._code=e.code?e.code:e.key;const el=e.target;if(this._inputValue=el.value,this._setMask(),38===e.keyCode&&e.preventDefault(),37===e.keyCode||8===e.keyCode||46===e.keyCode){if(8===e.keyCode&&0===el.value.length&&(el.selectionStart=el.selectionEnd),8===e.keyCode&&0!==el.selectionStart)if(this.specialCharacters=(null===(_a=this.specialCharacters)||void 0===_a?void 0:_a.length)?this.specialCharacters:this._config.specialCharacters,this.prefix.length>1&&el.selectionStart<=this.prefix.length)el.setSelectionRange(this.prefix.length,this.prefix.length);else{if(this._inputValue.length!==el.selectionStart&&1!==el.selectionStart)for(;this.specialCharacters.includes(this._inputValue[el.selectionStart-1].toString())&&(this.prefix.length>=1&&el.selectionStart>this.prefix.length||0===this.prefix.length);)el.setSelectionRange(el.selectionStart-1,el.selectionStart-1);this.suffixCheckOnPressDelete(e.keyCode,el)}this.suffixCheckOnPressDelete(e.keyCode,el),this._maskService.prefix.length&&el.selectionStart<=this._maskService.prefix.length&&el.selectionEnd<=this._maskService.prefix.length&&e.preventDefault();const cursorStart=el.selectionStart;8!==e.keyCode||el.readOnly||0!==cursorStart||el.selectionEnd!==el.value.length||0===el.value.length||(this._position=this._maskService.prefix?this._maskService.prefix.length:0,this._maskService.applyMask(this._maskService.prefix,this._maskService.maskExpression,this._position))}this.suffix&&this.suffix.length>1&&this._inputValue.length-this.suffix.length<el.selectionStart?el.setSelectionRange(this._inputValue.length-this.suffix.length,this._inputValue.length):(65===e.keyCode&&!0===e.ctrlKey||65===e.keyCode&&!0===e.metaKey)&&(el.setSelectionRange(0,this._getActualInputLength()),e.preventDefault()),this._maskService.selStart=el.selectionStart,this._maskService.selEnd=el.selectionEnd}writeValue(inputValue){return Object(tslib__WEBPACK_IMPORTED_MODULE_1__.b)(this,void 0,void 0,function*(){\"object\"==typeof inputValue&&null!==inputValue&&\"value\"in inputValue&&(\"disable\"in inputValue&&this.setDisabledState(Boolean(inputValue.disable)),inputValue=inputValue.value),void 0===inputValue&&(inputValue=\"\"),\"number\"==typeof inputValue&&(inputValue=String(inputValue),inputValue=\".\"!==this.decimalMarker?inputValue.replace(\".\",this.decimalMarker):inputValue,this._maskService.isNumberValue=!0),inputValue&&this._maskService.maskExpression||this._maskService.maskExpression&&(this._maskService.prefix||this._maskService.showMaskTyped)?(this._maskService.writingValue=!0,this._maskService.formElementProperty=[\"value\",this._maskService.applyMask(inputValue,this._maskService.maskExpression)],this._maskService.writingValue=!1):this._maskService.formElementProperty=[\"value\",inputValue],this._inputValue=inputValue})}registerOnChange(fn){this.onChange=fn,this._maskService.onChange=this.onChange}registerOnTouched(fn){this.onTouch=fn}suffixCheckOnPressDelete(keyCode,el){46===keyCode&&this.suffix.length>0&&this._inputValue.length-this.suffix.length<=el.selectionStart&&el.setSelectionRange(this._inputValue.length-this.suffix.length,this._inputValue.length),8===keyCode&&(this.suffix.length>1&&this._inputValue.length-this.suffix.length<el.selectionStart&&el.setSelectionRange(this._inputValue.length-this.suffix.length,this._inputValue.length),1===this.suffix.length&&this._inputValue.length===el.selectionStart&&el.setSelectionRange(el.selectionStart-1,el.selectionStart-1))}setDisabledState(isDisabled){this._maskService.formElementProperty=[\"disabled\",isDisabled]}_repeatPatternSymbols(maskExp){return maskExp.match(/{[0-9]+}/)&&maskExp.split(\"\").reduce((accum,currval,index)=>{if(this._start=\"{\"===currval?index:this._start,\"}\"!==currval)return this._maskService._findSpecialChar(currval)?accum+currval:accum;this._end=index;const repeatNumber=Number(maskExp.slice(this._start+1,this._end));return accum+new Array(repeatNumber+1).join(maskExp[this._start-1])},\"\")||maskExp}_applyMask(){this._maskService.maskExpression=this._repeatPatternSymbols(this._maskValue||\"\"),this._maskService.formElementProperty=[\"value\",this._maskService.applyMask(this._inputValue,this._maskService.maskExpression)]}_validateTime(value){const rowMaskLen=this._maskValue.split(\"\").filter(s=>\":\"!==s).length;return null===value||0===value.length?null:0==+value[value.length-1]&&value.length<rowMaskLen||value.length<=rowMaskLen-2?this._createValidationError(value):null}_getActualInputLength(){return this._maskService.actualValue.length||this._maskService.actualValue.length+this._maskService.prefix.length}_createValidationError(actualValue){return{mask:{requiredMask:this._maskValue,actualValue:actualValue}}}_setMask(){this._maskExpressionArray.length>0&&this._maskExpressionArray.some(mask=>{const test=this._maskService.removeMask(this._inputValue).length<=this._maskService.removeMask(mask).length;if(this._inputValue&&test)return this._maskValue=mask,this.maskExpression=mask,this._maskService.maskExpression=mask,test;this._maskValue=this._maskExpressionArray[this._maskExpressionArray.length-1],this.maskExpression=this._maskExpressionArray[this._maskExpressionArray.length-1],this._maskService.maskExpression=this._maskExpressionArray[this._maskExpressionArray.length-1]})}}return MaskDirective.ɵfac=function(t){return new(t||MaskDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(_angular_common__WEBPACK_IMPORTED_MODULE_3__.d),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(MaskService),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(config))},MaskDirective.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb({type:MaskDirective,selectors:[[\"input\",\"mask\",\"\"],[\"textarea\",\"mask\",\"\"]],hostBindings:function(rf,ctx){1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(\"paste\",function(){return ctx.onPaste()})(\"input\",function($event){return ctx.onInput($event)})(\"blur\",function(){return ctx.onBlur()})(\"click\",function($event){return ctx.onFocus($event)})(\"keydown\",function($event){return ctx.onKeyDown($event)})},inputs:{maskExpression:[\"mask\",\"maskExpression\"],specialCharacters:\"specialCharacters\",patterns:\"patterns\",prefix:\"prefix\",suffix:\"suffix\",thousandSeparator:\"thousandSeparator\",decimalMarker:\"decimalMarker\",dropSpecialCharacters:\"dropSpecialCharacters\",hiddenInput:\"hiddenInput\",showMaskTyped:\"showMaskTyped\",placeHolderCharacter:\"placeHolderCharacter\",shownMaskExpression:\"shownMaskExpression\",showTemplate:\"showTemplate\",clearIfNotMatch:\"clearIfNotMatch\",validation:\"validation\",separatorLimit:\"separatorLimit\",allowNegativeNumbers:\"allowNegativeNumbers\",leadZeroDateTime:\"leadZeroDateTime\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_0__.xb([{provide:_angular_forms__WEBPACK_IMPORTED_MODULE_2__.h,useExisting:Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.T)(()=>MaskDirective),multi:!0},{provide:_angular_forms__WEBPACK_IMPORTED_MODULE_2__.g,useExisting:Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.T)(()=>MaskDirective),multi:!0},MaskService]),_angular_core__WEBPACK_IMPORTED_MODULE_0__.wb]}),MaskDirective})(),NgxMaskModule=(()=>{class NgxMaskModule{static forRoot(configValue){return{ngModule:NgxMaskModule,providers:[{provide:NEW_CONFIG,useValue:configValue},{provide:INITIAL_CONFIG,useValue:initialConfig},{provide:config,useFactory:_configFactory,deps:[INITIAL_CONFIG,NEW_CONFIG]},MaskApplierService]}}static forChild(){return{ngModule:NgxMaskModule}}}return NgxMaskModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({type:NgxMaskModule}),NgxMaskModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib({factory:function(t){return new(t||NgxMaskModule)}}),NgxMaskModule})();function _configFactory(initConfig,configValue){return Object.assign(Object.assign({},initConfig),configValue instanceof Function?configValue():configValue)}const commonjsGlobal=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};commonjsGlobal.KeyboardEvent||(commonjsGlobal.KeyboardEvent=function(_eventType,_init){})}}]);","name":"7-es2015.0cf12740c374dbfbfcc4.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[7],{\n\n/***/ \"tmjD\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export INITIAL_CONFIG */\n/* unused harmony export MaskApplierService */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MaskDirective; });\n/* unused harmony export MaskPipe */\n/* unused harmony export MaskService */\n/* unused harmony export NEW_CONFIG */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return NgxMaskModule; });\n/* unused harmony export _configFactory */\n/* unused harmony export config */\n/* unused harmony export initialConfig */\n/* unused harmony export timeMasks */\n/* unused harmony export withoutValidation */\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"mrSG\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"3Pt+\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"ofXK\");\n\n\n\n\n\nconst config = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* InjectionToken */ \"r\"]('config');\nconst NEW_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* InjectionToken */ \"r\"]('NEW_CONFIG');\nconst INITIAL_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* InjectionToken */ \"r\"]('INITIAL_CONFIG');\nconst initialConfig = {\n    suffix: '',\n    prefix: '',\n    thousandSeparator: ' ',\n    decimalMarker: '.',\n    clearIfNotMatch: false,\n    showTemplate: false,\n    showMaskTyped: false,\n    placeHolderCharacter: '_',\n    dropSpecialCharacters: true,\n    hiddenInput: undefined,\n    shownMaskExpression: '',\n    separatorLimit: '',\n    allowNegativeNumbers: false,\n    validation: true,\n    // tslint:disable-next-line: quotemark\n    specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\"', \"'\"],\n    leadZeroDateTime: false,\n    patterns: {\n        '0': {\n            pattern: new RegExp('\\\\d'),\n        },\n        '9': {\n            pattern: new RegExp('\\\\d'),\n            optional: true,\n        },\n        X: {\n            pattern: new RegExp('\\\\d'),\n            symbol: '*',\n        },\n        A: {\n            pattern: new RegExp('[a-zA-Z0-9]'),\n        },\n        S: {\n            pattern: new RegExp('[a-zA-Z]'),\n        },\n        d: {\n            pattern: new RegExp('\\\\d'),\n        },\n        m: {\n            pattern: new RegExp('\\\\d'),\n        },\n        M: {\n            pattern: new RegExp('\\\\d'),\n        },\n        H: {\n            pattern: new RegExp('\\\\d'),\n        },\n        h: {\n            pattern: new RegExp('\\\\d'),\n        },\n        s: {\n            pattern: new RegExp('\\\\d'),\n        },\n    },\n};\nconst timeMasks = ['Hh:m0:s0', 'Hh:m0', 'm0:s0'];\nconst withoutValidation = [\n    'percent',\n    'Hh',\n    's0',\n    'm0',\n    'separator',\n    'd0/M0/0000',\n    'd0/M0',\n    'd0',\n    'M0',\n];\nlet MaskApplierService = /*@__PURE__*/ (() => {\n    class MaskApplierService {\n        constructor(_config) {\n            this._config = _config;\n            this.maskExpression = '';\n            this.actualValue = '';\n            this.shownMaskExpression = '';\n            this._formatWithSeparators = (str, thousandSeparatorChar, decimalChar, precision) => {\n                const x = str.split(decimalChar);\n                const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : '';\n                let res = x[0];\n                const separatorLimit = this.separatorLimit.replace(/\\s/g, '');\n                if (separatorLimit && +separatorLimit) {\n                    if (res[0] === '-') {\n                        res = `-${res.slice(1, res.length).slice(0, separatorLimit.length)}`;\n                    }\n                    else {\n                        res = res.slice(0, separatorLimit.length);\n                    }\n                }\n                const rgx = /(\\d+)(\\d{3})/;\n                while (thousandSeparatorChar && rgx.test(res)) {\n                    res = res.replace(rgx, '$1' + thousandSeparatorChar + '$2');\n                }\n                if (precision === undefined) {\n                    return res + decimals;\n                }\n                else if (precision === 0) {\n                    return res;\n                }\n                return res + decimals.substr(0, precision + 1);\n            };\n            this.percentage = (str) => {\n                return Number(str) >= 0 && Number(str) <= 100;\n            };\n            this.getPrecision = (maskExpression) => {\n                const x = maskExpression.split('.');\n                if (x.length > 1) {\n                    return Number(x[x.length - 1]);\n                }\n                return Infinity;\n            };\n            this.checkAndRemoveSuffix = (inputValue) => {\n                var _a, _b, _c;\n                for (let i = ((_a = this.suffix) === null || _a === void 0 ? void 0 : _a.length) - 1; i >= 0; i--) {\n                    const substr = this.suffix.substr(i, (_b = this.suffix) === null || _b === void 0 ? void 0 : _b.length);\n                    if (inputValue.includes(substr) &&\n                        (i - 1 < 0 || !inputValue.includes(this.suffix.substr(i - 1, (_c = this.suffix) === null || _c === void 0 ? void 0 : _c.length)))) {\n                        return inputValue.replace(substr, '');\n                    }\n                }\n                return inputValue;\n            };\n            this.checkInputPrecision = (inputValue, precision, decimalMarker) => {\n                if (precision < Infinity) {\n                    const precisionRegEx = new RegExp(this._charToRegExpExpression(decimalMarker) + `\\\\d{${precision}}.*$`);\n                    const precisionMatch = inputValue.match(precisionRegEx);\n                    if (precisionMatch && precisionMatch[0].length - 1 > precision) {\n                        const diff = precisionMatch[0].length - 1 - precision;\n                        inputValue = inputValue.substring(0, inputValue.length - diff);\n                    }\n                    if (precision === 0 && inputValue.endsWith(decimalMarker)) {\n                        inputValue = inputValue.substring(0, inputValue.length - 1);\n                    }\n                }\n                return inputValue;\n            };\n            this._shift = new Set();\n            this.clearIfNotMatch = this._config.clearIfNotMatch;\n            this.dropSpecialCharacters = this._config.dropSpecialCharacters;\n            this.maskSpecialCharacters = this._config.specialCharacters;\n            this.maskAvailablePatterns = this._config.patterns;\n            this.prefix = this._config.prefix;\n            this.suffix = this._config.suffix;\n            this.thousandSeparator = this._config.thousandSeparator;\n            this.decimalMarker = this._config.decimalMarker;\n            this.hiddenInput = this._config.hiddenInput;\n            this.showMaskTyped = this._config.showMaskTyped;\n            this.placeHolderCharacter = this._config.placeHolderCharacter;\n            this.validation = this._config.validation;\n            this.separatorLimit = this._config.separatorLimit;\n            this.allowNegativeNumbers = this._config.allowNegativeNumbers;\n            this.leadZeroDateTime = this._config.leadZeroDateTime;\n        }\n        applyMaskWithPattern(inputValue, maskAndPattern) {\n            const [mask, customPattern] = maskAndPattern;\n            this.customPattern = customPattern;\n            return this.applyMask(inputValue, mask);\n        }\n        applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false, cb = () => { }) {\n            if (inputValue === undefined || inputValue === null || maskExpression === undefined) {\n                return '';\n            }\n            let cursor = 0;\n            let result = '';\n            let multi = false;\n            let backspaceShift = false;\n            let shift = 1;\n            let stepBack = false;\n            if (inputValue.slice(0, this.prefix.length) === this.prefix) {\n                inputValue = inputValue.slice(this.prefix.length, inputValue.length);\n            }\n            if (!!this.suffix && (inputValue === null || inputValue === void 0 ? void 0 : inputValue.length) > 0) {\n                inputValue = this.checkAndRemoveSuffix(inputValue);\n            }\n            const inputArray = inputValue.toString().split('');\n            if (maskExpression === 'IP') {\n                this.ipError = !!(inputArray.filter((i) => i === '.').length < 3 && inputArray.length < 7);\n                maskExpression = '099.099.099.099';\n            }\n            const arr = [];\n            for (let i = 0; i < inputValue.length; i++) {\n                if (inputValue[i].match('\\\\d')) {\n                    arr.push(inputValue[i]);\n                }\n            }\n            if (maskExpression === 'CPF_CNPJ') {\n                this.cpfCnpjError = !!(arr.length !== 11 && arr.length !== 14);\n                if (arr.length > 11) {\n                    maskExpression = '00.000.000/0000-00';\n                }\n                else {\n                    maskExpression = '000.000.000-00';\n                }\n            }\n            if (maskExpression.startsWith('percent')) {\n                if (inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/)) {\n                    inputValue = this._stripToDecimal(inputValue);\n                    const precision = this.getPrecision(maskExpression);\n                    inputValue = this.checkInputPrecision(inputValue, precision, this.decimalMarker);\n                }\n                if (inputValue.indexOf('.') > 0 && !this.percentage(inputValue.substring(0, inputValue.indexOf('.')))) {\n                    const base = inputValue.substring(0, inputValue.indexOf('.') - 1);\n                    inputValue = `${base}${inputValue.substring(inputValue.indexOf('.'), inputValue.length)}`;\n                }\n                if (this.percentage(inputValue)) {\n                    result = inputValue;\n                }\n                else {\n                    result = inputValue.substring(0, inputValue.length - 1);\n                }\n            }\n            else if (maskExpression.startsWith('separator')) {\n                if (inputValue.match('[wа-яА-Я]') ||\n                    inputValue.match('[ЁёА-я]') ||\n                    inputValue.match('[a-z]|[A-Z]') ||\n                    inputValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\[\\]:\";<>.?\\/]/) ||\n                    inputValue.match('[^A-Za-z0-9,]')) {\n                    inputValue = this._stripToDecimal(inputValue);\n                }\n                inputValue =\n                    inputValue.length > 1 && inputValue[0] === '0' && inputValue[1] !== this.decimalMarker\n                        ? inputValue.slice(1, inputValue.length)\n                        : inputValue;\n                // TODO: we had different rexexps here for the different cases... but tests dont seam to bother - check this\n                //  separator: no COMMA, dot-sep: no SPACE, COMMA OK, comma-sep: no SPACE, COMMA OK\n                const thousandSeperatorCharEscaped = this._charToRegExpExpression(this.thousandSeparator);\n                const decimalMarkerEscaped = this._charToRegExpExpression(this.decimalMarker);\n                const invalidChars = '@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'\n                    .replace(thousandSeperatorCharEscaped, '')\n                    .replace(decimalMarkerEscaped, '');\n                const invalidCharRegexp = new RegExp('[' + invalidChars + ']');\n                if (inputValue.match(invalidCharRegexp)) {\n                    inputValue = inputValue.substring(0, inputValue.length - 1);\n                }\n                const precision = this.getPrecision(maskExpression);\n                inputValue = this.checkInputPrecision(inputValue, precision, this.decimalMarker);\n                const strForSep = inputValue.replace(new RegExp(thousandSeperatorCharEscaped, 'g'), '');\n                result = this._formatWithSeparators(strForSep, this.thousandSeparator, this.decimalMarker, precision);\n                const commaShift = result.indexOf(',') - inputValue.indexOf(',');\n                const shiftStep = result.length - inputValue.length;\n                if (shiftStep > 0 && result[position] !== ',') {\n                    backspaceShift = true;\n                    let _shift = 0;\n                    do {\n                        this._shift.add(position + _shift);\n                        _shift++;\n                    } while (_shift < shiftStep);\n                }\n                else if ((commaShift !== 0 && position > 0 && !(result.indexOf(',') >= position && position > 3)) ||\n                    (!(result.indexOf('.') >= position && position > 3) && shiftStep <= 0)) {\n                    this._shift.clear();\n                    backspaceShift = true;\n                    shift = shiftStep;\n                    position += shiftStep;\n                    this._shift.add(position);\n                }\n                else {\n                    this._shift.clear();\n                }\n            }\n            else {\n                for (\n                // tslint:disable-next-line\n                let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i]) {\n                    if (cursor === maskExpression.length) {\n                        break;\n                    }\n                    if (this._checkSymbolMask(inputSymbol, maskExpression[cursor]) && maskExpression[cursor + 1] === '?') {\n                        result += inputSymbol;\n                        cursor += 2;\n                    }\n                    else if (maskExpression[cursor + 1] === '*' &&\n                        multi &&\n                        this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2])) {\n                        result += inputSymbol;\n                        cursor += 3;\n                        multi = false;\n                    }\n                    else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor]) && maskExpression[cursor + 1] === '*') {\n                        result += inputSymbol;\n                        multi = true;\n                    }\n                    else if (maskExpression[cursor + 1] === '?' &&\n                        this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2])) {\n                        result += inputSymbol;\n                        cursor += 3;\n                    }\n                    else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor])) {\n                        if (maskExpression[cursor] === 'H') {\n                            if (Number(inputSymbol) > 2) {\n                                cursor += 1;\n                                this._shiftStep(maskExpression, cursor, inputArray.length);\n                                i--;\n                                if (this.leadZeroDateTime) {\n                                    result += '0';\n                                }\n                                continue;\n                            }\n                        }\n                        if (maskExpression[cursor] === 'h') {\n                            if (result === '2' && Number(inputSymbol) > 3) {\n                                cursor += 1;\n                                i--;\n                                continue;\n                            }\n                        }\n                        if (maskExpression[cursor] === 'm') {\n                            if (Number(inputSymbol) > 5) {\n                                cursor += 1;\n                                this._shiftStep(maskExpression, cursor, inputArray.length);\n                                i--;\n                                if (this.leadZeroDateTime) {\n                                    result += '0';\n                                }\n                                continue;\n                            }\n                        }\n                        if (maskExpression[cursor] === 's') {\n                            if (Number(inputSymbol) > 5) {\n                                cursor += 1;\n                                this._shiftStep(maskExpression, cursor, inputArray.length);\n                                i--;\n                                if (this.leadZeroDateTime) {\n                                    result += '0';\n                                }\n                                continue;\n                            }\n                        }\n                        const daysCount = 31;\n                        if (maskExpression[cursor] === 'd') {\n                            if ((Number(inputSymbol) > 3 && this.leadZeroDateTime) ||\n                                Number(inputValue.slice(cursor, cursor + 2)) > daysCount ||\n                                inputValue[cursor + 1] === '/') {\n                                cursor += 1;\n                                this._shiftStep(maskExpression, cursor, inputArray.length);\n                                i--;\n                                if (this.leadZeroDateTime) {\n                                    result += '0';\n                                }\n                                continue;\n                            }\n                        }\n                        if (maskExpression[cursor] === 'M') {\n                            const monthsCount = 12;\n                            // mask without day\n                            const withoutDays = cursor === 0 &&\n                                (Number(inputSymbol) > 2 ||\n                                    Number(inputValue.slice(cursor, cursor + 2)) > monthsCount ||\n                                    inputValue[cursor + 1] === '/');\n                            // day<10 && month<12 for input\n                            const day1monthInput = inputValue.slice(cursor - 3, cursor - 1).includes('/') &&\n                                ((inputValue[cursor - 2] === '/' &&\n                                    Number(inputValue.slice(cursor - 1, cursor + 1)) > monthsCount &&\n                                    inputValue[cursor] !== '/') ||\n                                    inputValue[cursor] === '/' ||\n                                    (inputValue[cursor - 3] === '/' &&\n                                        Number(inputValue.slice(cursor - 2, cursor)) > monthsCount &&\n                                        inputValue[cursor - 1] !== '/') ||\n                                    inputValue[cursor - 1] === '/');\n                            // 10<day<31 && month<12 for input\n                            const day2monthInput = Number(inputValue.slice(cursor - 3, cursor - 1)) <= daysCount &&\n                                !inputValue.slice(cursor - 3, cursor - 1).includes('/') &&\n                                inputValue[cursor - 1] === '/' &&\n                                (Number(inputValue.slice(cursor, cursor + 2)) > monthsCount || inputValue[cursor + 1] === '/');\n                            // day<10 && month<12 for paste whole data\n                            const day1monthPaste = Number(inputValue.slice(cursor - 3, cursor - 1)) > daysCount &&\n                                !inputValue.slice(cursor - 3, cursor - 1).includes('/') &&\n                                !inputValue.slice(cursor - 2, cursor).includes('/') &&\n                                Number(inputValue.slice(cursor - 2, cursor)) > monthsCount;\n                            // 10<day<31 && month<12 for paste whole data\n                            const day2monthPaste = Number(inputValue.slice(cursor - 3, cursor - 1)) <= daysCount &&\n                                !inputValue.slice(cursor - 3, cursor - 1).includes('/') &&\n                                inputValue[cursor - 1] !== '/' &&\n                                Number(inputValue.slice(cursor - 1, cursor + 1)) > monthsCount;\n                            if ((Number(inputSymbol) > 1 && this.leadZeroDateTime) ||\n                                withoutDays ||\n                                day1monthInput ||\n                                day2monthInput ||\n                                day1monthPaste ||\n                                day2monthPaste) {\n                                cursor += 1;\n                                this._shiftStep(maskExpression, cursor, inputArray.length);\n                                i--;\n                                if (this.leadZeroDateTime) {\n                                    result += '0';\n                                }\n                                continue;\n                            }\n                        }\n                        result += inputSymbol;\n                        cursor++;\n                    }\n                    else if (this.maskSpecialCharacters.indexOf(maskExpression[cursor]) !== -1) {\n                        result += maskExpression[cursor];\n                        cursor++;\n                        this._shiftStep(maskExpression, cursor, inputArray.length);\n                        i--;\n                    }\n                    else if (this.maskSpecialCharacters.indexOf(inputSymbol) > -1 &&\n                        this.maskAvailablePatterns[maskExpression[cursor]] &&\n                        this.maskAvailablePatterns[maskExpression[cursor]].optional) {\n                        if (!!inputArray[cursor] &&\n                            maskExpression !== '099.099.099.099' &&\n                            maskExpression !== '000.000.000-00' &&\n                            maskExpression !== '00.000.000/0000-00') {\n                            result += inputArray[cursor];\n                        }\n                        cursor++;\n                        i--;\n                    }\n                    else if (this.maskExpression[cursor + 1] === '*' &&\n                        this._findSpecialChar(this.maskExpression[cursor + 2]) &&\n                        this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] &&\n                        multi) {\n                        cursor += 3;\n                        result += inputSymbol;\n                    }\n                    else if (this.maskExpression[cursor + 1] === '?' &&\n                        this._findSpecialChar(this.maskExpression[cursor + 2]) &&\n                        this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] &&\n                        multi) {\n                        cursor += 3;\n                        result += inputSymbol;\n                    }\n                    else if (this.showMaskTyped &&\n                        this.maskSpecialCharacters.indexOf(inputSymbol) < 0 &&\n                        inputSymbol !== this.placeHolderCharacter) {\n                        stepBack = true;\n                    }\n                }\n            }\n            if (result.length + 1 === maskExpression.length &&\n                this.maskSpecialCharacters.indexOf(maskExpression[maskExpression.length - 1]) !== -1) {\n                result += maskExpression[maskExpression.length - 1];\n            }\n            let newPosition = position + 1;\n            while (this._shift.has(newPosition)) {\n                shift++;\n                newPosition++;\n            }\n            let actualShift = justPasted ? cursor : this._shift.has(position) ? shift : 0;\n            if (stepBack) {\n                actualShift--;\n            }\n            cb(actualShift, backspaceShift);\n            if (shift < 0) {\n                this._shift.clear();\n            }\n            let onlySpecial = false;\n            if (backspaced) {\n                onlySpecial = inputArray.every((char) => this.maskSpecialCharacters.includes(char));\n            }\n            let res = `${this.prefix}${onlySpecial ? '' : result}${this.suffix}`;\n            if (result.length === 0) {\n                res = `${this.prefix}${result}`;\n            }\n            return res;\n        }\n        _findSpecialChar(inputSymbol) {\n            return this.maskSpecialCharacters.find((val) => val === inputSymbol);\n        }\n        _checkSymbolMask(inputSymbol, maskSymbol) {\n            this.maskAvailablePatterns = this.customPattern ? this.customPattern : this.maskAvailablePatterns;\n            return (this.maskAvailablePatterns[maskSymbol] &&\n                this.maskAvailablePatterns[maskSymbol].pattern &&\n                this.maskAvailablePatterns[maskSymbol].pattern.test(inputSymbol));\n        }\n        _stripToDecimal(str) {\n            return str\n                .split('')\n                .filter((i, idx) => {\n                return (i.match('^-?\\\\d') ||\n                    i.match('\\\\s') ||\n                    i === '.' ||\n                    i === ',' ||\n                    (i === '-' && idx === 0 && this.allowNegativeNumbers));\n            })\n                .join('');\n        }\n        _charToRegExpExpression(char) {\n            if (char) {\n                const charsToEscape = '[\\\\^$.|?*+()';\n                return char === ' ' ? '\\\\s' : charsToEscape.indexOf(char) >= 0 ? '\\\\' + char : char;\n            }\n            return char;\n        }\n        _shiftStep(maskExpression, cursor, inputLength) {\n            const shiftStep = /[*?]/g.test(maskExpression.slice(0, cursor)) ? inputLength : cursor;\n            this._shift.add(shiftStep + this.prefix.length || 0);\n        }\n    }\n    MaskApplierService.ɵfac = function MaskApplierService_Factory(t) { return new (t || MaskApplierService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵinject */ \"Yb\"](config)); };\n    MaskApplierService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjectable */ \"Hb\"]({ token: MaskApplierService, factory: MaskApplierService.ɵfac });\n    return MaskApplierService;\n})();\nlet MaskService = /*@__PURE__*/ (() => {\n    class MaskService extends MaskApplierService {\n        constructor(document, _config, _elementRef, _renderer) {\n            super(_config);\n            this.document = document;\n            this._config = _config;\n            this._elementRef = _elementRef;\n            this._renderer = _renderer;\n            this.maskExpression = '';\n            this.isNumberValue = false;\n            this.placeHolderCharacter = '_';\n            this.maskIsShown = '';\n            this.selStart = null;\n            this.selEnd = null;\n            /**\n             * Whether we are currently in writeValue function, in this case when applying the mask we don't want to trigger onChange function,\n             * since writeValue should be a one way only process of writing the DOM value based on the Angular model value.\n             */\n            this.writingValue = false;\n            this.onChange = (_) => { };\n        }\n        // tslint:disable-next-line:cyclomatic-complexity\n        applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false, cb = () => { }) {\n            if (!maskExpression) {\n                return inputValue;\n            }\n            this.maskIsShown = this.showMaskTyped ? this.showMaskInInput() : '';\n            if (this.maskExpression === 'IP' && this.showMaskTyped) {\n                this.maskIsShown = this.showMaskInInput(inputValue || '#');\n            }\n            if (this.maskExpression === 'CPF_CNPJ' && this.showMaskTyped) {\n                this.maskIsShown = this.showMaskInInput(inputValue || '#');\n            }\n            if (!inputValue && this.showMaskTyped) {\n                this.formControlResult(this.prefix);\n                return this.prefix + this.maskIsShown;\n            }\n            const getSymbol = !!inputValue && typeof this.selStart === 'number' ? inputValue[this.selStart] : '';\n            let newInputValue = '';\n            if (this.hiddenInput !== undefined) {\n                let actualResult = this.actualValue.split('');\n                // tslint:disable no-unused-expression\n                inputValue !== '' && actualResult.length\n                    ? typeof this.selStart === 'number' && typeof this.selEnd === 'number'\n                        ? inputValue.length > actualResult.length\n                            ? actualResult.splice(this.selStart, 0, getSymbol)\n                            : inputValue.length < actualResult.length\n                                ? actualResult.length - inputValue.length === 1\n                                    ? actualResult.splice(this.selStart - 1, 1)\n                                    : actualResult.splice(this.selStart, this.selEnd - this.selStart)\n                                : null\n                        : null\n                    : (actualResult = []);\n                // tslint:enable no-unused-expression\n                newInputValue = this.actualValue.length ? this.shiftTypedSymbols(actualResult.join('')) : inputValue;\n            }\n            newInputValue = Boolean(newInputValue) && newInputValue.length ? newInputValue : inputValue;\n            const result = super.applyMask(newInputValue, maskExpression, position, justPasted, backspaced, cb);\n            this.actualValue = this.getActualValue(result);\n            // handle some separator implications:\n            // a.) adjust decimalMarker default (. -> ,) if thousandSeparator is a dot\n            if (this.thousandSeparator === '.' && this.decimalMarker === '.') {\n                this.decimalMarker = ',';\n            }\n            // b) remove decimal marker from list of special characters to mask\n            if (this.maskExpression.startsWith('separator') && this.dropSpecialCharacters === true) {\n                this.maskSpecialCharacters = this.maskSpecialCharacters.filter((item) => item !== this.decimalMarker);\n            }\n            this.formControlResult(result);\n            if (!this.showMaskTyped) {\n                if (this.hiddenInput) {\n                    return result && result.length ? this.hideInput(result, this.maskExpression) : result;\n                }\n                return result;\n            }\n            const resLen = result.length;\n            const prefNmask = this.prefix + this.maskIsShown;\n            if (this.maskExpression.includes('H')) {\n                const countSkipedSymbol = this._numberSkipedSymbols(result);\n                return result + prefNmask.slice(resLen + countSkipedSymbol);\n            }\n            else if (this.maskExpression === 'IP' || this.maskExpression === 'CPF_CNPJ') {\n                return result + prefNmask;\n            }\n            return result + prefNmask.slice(resLen);\n        }\n        // get the number of characters that were shifted\n        _numberSkipedSymbols(value) {\n            const regex = /(^|\\D)(\\d\\D)/g;\n            let match = regex.exec(value);\n            let countSkipedSymbol = 0;\n            while (match != null) {\n                countSkipedSymbol += 1;\n                match = regex.exec(value);\n            }\n            return countSkipedSymbol;\n        }\n        applyValueChanges(position = 0, justPasted, backspaced, cb = () => { }) {\n            const formElement = this._elementRef.nativeElement;\n            formElement.value = this.applyMask(formElement.value, this.maskExpression, position, justPasted, backspaced, cb);\n            if (formElement === this.document.activeElement) {\n                return;\n            }\n            this.clearIfNotMatchFn();\n        }\n        hideInput(inputValue, maskExpression) {\n            return inputValue\n                .split('')\n                .map((curr, index) => {\n                if (this.maskAvailablePatterns &&\n                    this.maskAvailablePatterns[maskExpression[index]] &&\n                    this.maskAvailablePatterns[maskExpression[index]].symbol) {\n                    return this.maskAvailablePatterns[maskExpression[index]].symbol;\n                }\n                return curr;\n            })\n                .join('');\n        }\n        // this function is not necessary, it checks result against maskExpression\n        getActualValue(res) {\n            const compare = res\n                .split('')\n                .filter((symbol, i) => this._checkSymbolMask(symbol, this.maskExpression[i]) ||\n                (this.maskSpecialCharacters.includes(this.maskExpression[i]) && symbol === this.maskExpression[i]));\n            if (compare.join('') === res) {\n                return compare.join('');\n            }\n            return res;\n        }\n        shiftTypedSymbols(inputValue) {\n            let symbolToReplace = '';\n            const newInputValue = (inputValue &&\n                inputValue.split('').map((currSymbol, index) => {\n                    if (this.maskSpecialCharacters.includes(inputValue[index + 1]) &&\n                        inputValue[index + 1] !== this.maskExpression[index + 1]) {\n                        symbolToReplace = currSymbol;\n                        return inputValue[index + 1];\n                    }\n                    if (symbolToReplace.length) {\n                        const replaceSymbol = symbolToReplace;\n                        symbolToReplace = '';\n                        return replaceSymbol;\n                    }\n                    return currSymbol;\n                })) ||\n                [];\n            return newInputValue.join('');\n        }\n        showMaskInInput(inputVal) {\n            if (this.showMaskTyped && !!this.shownMaskExpression) {\n                if (this.maskExpression.length !== this.shownMaskExpression.length) {\n                    throw new Error('Mask expression must match mask placeholder length');\n                }\n                else {\n                    return this.shownMaskExpression;\n                }\n            }\n            else if (this.showMaskTyped) {\n                if (inputVal) {\n                    if (this.maskExpression === 'IP') {\n                        return this._checkForIp(inputVal);\n                    }\n                    if (this.maskExpression === 'CPF_CNPJ') {\n                        return this._checkForCpfCnpj(inputVal);\n                    }\n                }\n                return this.maskExpression.replace(/\\w/g, this.placeHolderCharacter);\n            }\n            return '';\n        }\n        clearIfNotMatchFn() {\n            const formElement = this._elementRef.nativeElement;\n            if (this.clearIfNotMatch &&\n                this.prefix.length + this.maskExpression.length + this.suffix.length !==\n                    formElement.value.replace(/_/g, '').length) {\n                this.formElementProperty = ['value', ''];\n                this.applyMask(formElement.value, this.maskExpression);\n            }\n        }\n        set formElementProperty([name, value]) {\n            Promise.resolve().then(() => this._renderer.setProperty(this._elementRef.nativeElement, name, value));\n        }\n        checkSpecialCharAmount(mask) {\n            const chars = mask.split('').filter((item) => this._findSpecialChar(item));\n            return chars.length;\n        }\n        removeMask(inputValue) {\n            return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.maskSpecialCharacters.concat('_').concat(this.placeHolderCharacter));\n        }\n        _checkForIp(inputVal) {\n            if (inputVal === '#') {\n                return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n            }\n            const arr = [];\n            for (let i = 0; i < inputVal.length; i++) {\n                if (inputVal[i].match('\\\\d')) {\n                    arr.push(inputVal[i]);\n                }\n            }\n            if (arr.length <= 3) {\n                return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n            }\n            if (arr.length > 3 && arr.length <= 6) {\n                return `${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n            }\n            if (arr.length > 6 && arr.length <= 9) {\n                return this.placeHolderCharacter;\n            }\n            if (arr.length > 9 && arr.length <= 12) {\n                return '';\n            }\n            return '';\n        }\n        _checkForCpfCnpj(inputVal) {\n            const cpf = `${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n            const cnpj = `${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n                `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n            if (inputVal === '#') {\n                return cpf;\n            }\n            const arr = [];\n            for (let i = 0; i < inputVal.length; i++) {\n                if (inputVal[i].match('\\\\d')) {\n                    arr.push(inputVal[i]);\n                }\n            }\n            if (arr.length <= 3) {\n                return cpf.slice(arr.length, cpf.length);\n            }\n            if (arr.length > 3 && arr.length <= 6) {\n                return cpf.slice(arr.length + 1, cpf.length);\n            }\n            if (arr.length > 6 && arr.length <= 9) {\n                return cpf.slice(arr.length + 2, cpf.length);\n            }\n            if (arr.length > 9 && arr.length < 11) {\n                return cpf.slice(arr.length + 3, cpf.length);\n            }\n            if (arr.length === 11) {\n                return '';\n            }\n            if (arr.length === 12) {\n                if (inputVal.length === 17) {\n                    return cnpj.slice(16, cnpj.length);\n                }\n                return cnpj.slice(15, cnpj.length);\n            }\n            if (arr.length > 12 && arr.length <= 14) {\n                return cnpj.slice(arr.length + 4, cnpj.length);\n            }\n            return '';\n        }\n        /**\n         * Propogates the input value back to the Angular model by triggering the onChange function. It won't do this if writingValue\n         * is true. If that is true it means we are currently in the writeValue function, which is supposed to only update the actual\n         * DOM element based on the Angular model value. It should be a one way process, i.e. writeValue should not be modifying the Angular\n         * model value too. Therefore, we don't trigger onChange in this scenario.\n         * @param inputValue the current form input value\n         */\n        formControlResult(inputValue) {\n            if (this.writingValue) {\n                return;\n            }\n            if (Array.isArray(this.dropSpecialCharacters)) {\n                this.onChange(this._toNumber(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.dropSpecialCharacters)));\n            }\n            else if (this.dropSpecialCharacters) {\n                this.onChange(this._toNumber(this._checkSymbols(inputValue)));\n            }\n            else {\n                this.onChange(this._removeSuffix(inputValue));\n            }\n        }\n        _toNumber(value) {\n            if (!this.isNumberValue) {\n                return value;\n            }\n            const num = Number(value);\n            return Number.isNaN(num) ? value : num;\n        }\n        _removeMask(value, specialCharactersForRemove) {\n            return value ? value.replace(this._regExpForRemove(specialCharactersForRemove), '') : value;\n        }\n        _removePrefix(value) {\n            if (!this.prefix) {\n                return value;\n            }\n            return value ? value.replace(this.prefix, '') : value;\n        }\n        _removeSuffix(value) {\n            if (!this.suffix) {\n                return value;\n            }\n            return value ? value.replace(this.suffix, '') : value;\n        }\n        _retrieveSeparatorValue(result) {\n            return this._removeMask(this._removeSuffix(this._removePrefix(result)), this.maskSpecialCharacters);\n        }\n        _regExpForRemove(specialCharactersForRemove) {\n            return new RegExp(specialCharactersForRemove.map((item) => `\\\\${item}`).join('|'), 'gi');\n        }\n        _checkSymbols(result) {\n            if (result === '') {\n                return result;\n            }\n            const separatorPrecision = this._retrieveSeparatorPrecision(this.maskExpression);\n            let separatorValue = this._retrieveSeparatorValue(result);\n            if (this.decimalMarker !== '.') {\n                separatorValue = separatorValue.replace(this.decimalMarker, '.');\n            }\n            if (!this.isNumberValue) {\n                return separatorValue;\n            }\n            if (separatorPrecision) {\n                if (result === this.decimalMarker) {\n                    return null;\n                }\n                return this._checkPrecision(this.maskExpression, separatorValue);\n            }\n            else {\n                return Number(separatorValue);\n            }\n        }\n        // TODO should think about helpers or separting decimal precision to own property\n        _retrieveSeparatorPrecision(maskExpretion) {\n            const matcher = maskExpretion.match(new RegExp(`^separator\\\\.([^d]*)`));\n            return matcher ? Number(matcher[1]) : null;\n        }\n        _checkPrecision(separatorExpression, separatorValue) {\n            if (separatorExpression.indexOf('2') > 0) {\n                return Number(separatorValue).toFixed(2);\n            }\n            return Number(separatorValue);\n        }\n    }\n    MaskService.ɵfac = function MaskService_Factory(t) { return new (t || MaskService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵinject */ \"Yb\"](_angular_common__WEBPACK_IMPORTED_MODULE_3__[/* DOCUMENT */ \"d\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵinject */ \"Yb\"](config), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵinject */ \"Yb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ElementRef */ \"l\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵinject */ \"Yb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* Renderer2 */ \"E\"])); };\n    MaskService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjectable */ \"Hb\"]({ token: MaskService, factory: MaskService.ɵfac });\n    return MaskService;\n})();\nlet MaskDirective = /*@__PURE__*/ (() => {\n    class MaskDirective {\n        constructor(document, _maskService, _config) {\n            this.document = document;\n            this._maskService = _maskService;\n            this._config = _config;\n            this.maskExpression = '';\n            this.specialCharacters = [];\n            this.patterns = {};\n            this.prefix = '';\n            this.suffix = '';\n            this.thousandSeparator = ' ';\n            this.decimalMarker = '.';\n            this.dropSpecialCharacters = null;\n            this.hiddenInput = null;\n            this.showMaskTyped = null;\n            this.placeHolderCharacter = null;\n            this.shownMaskExpression = null;\n            this.showTemplate = null;\n            this.clearIfNotMatch = null;\n            this.validation = null;\n            this.separatorLimit = null;\n            this.allowNegativeNumbers = null;\n            this.leadZeroDateTime = null;\n            this._maskValue = '';\n            this._position = null;\n            this._maskExpressionArray = [];\n            this._justPasted = false;\n            this.onChange = (_) => { };\n            this.onTouch = () => { };\n        }\n        ngOnChanges(changes) {\n            const { maskExpression, specialCharacters, patterns, prefix, suffix, thousandSeparator, decimalMarker, dropSpecialCharacters, hiddenInput, showMaskTyped, placeHolderCharacter, shownMaskExpression, showTemplate, clearIfNotMatch, validation, separatorLimit, allowNegativeNumbers, leadZeroDateTime, } = changes;\n            if (maskExpression) {\n                this._maskValue = maskExpression.currentValue || '';\n                if (maskExpression.currentValue && maskExpression.currentValue.split('||').length > 1) {\n                    this._maskExpressionArray = maskExpression.currentValue.split('||').sort((a, b) => {\n                        return a.length - b.length;\n                    });\n                    this._maskValue = this._maskExpressionArray[0];\n                    this.maskExpression = this._maskExpressionArray[0];\n                    this._maskService.maskExpression = this._maskExpressionArray[0];\n                }\n            }\n            if (specialCharacters) {\n                if (!specialCharacters.currentValue || !Array.isArray(specialCharacters.currentValue)) {\n                    return;\n                }\n                else {\n                    this._maskService.maskSpecialCharacters = specialCharacters.currentValue || [];\n                }\n            }\n            // Only overwrite the mask available patterns if a pattern has actually been passed in\n            if (patterns && patterns.currentValue) {\n                this._maskService.maskAvailablePatterns = patterns.currentValue;\n            }\n            if (prefix) {\n                this._maskService.prefix = prefix.currentValue;\n            }\n            if (suffix) {\n                this._maskService.suffix = suffix.currentValue;\n            }\n            if (thousandSeparator) {\n                this._maskService.thousandSeparator = thousandSeparator.currentValue;\n            }\n            if (decimalMarker) {\n                this._maskService.decimalMarker = decimalMarker.currentValue;\n            }\n            if (dropSpecialCharacters) {\n                this._maskService.dropSpecialCharacters = dropSpecialCharacters.currentValue;\n            }\n            if (hiddenInput) {\n                this._maskService.hiddenInput = hiddenInput.currentValue;\n            }\n            if (showMaskTyped) {\n                this._maskService.showMaskTyped = showMaskTyped.currentValue;\n            }\n            if (placeHolderCharacter) {\n                this._maskService.placeHolderCharacter = placeHolderCharacter.currentValue;\n            }\n            if (shownMaskExpression) {\n                this._maskService.shownMaskExpression = shownMaskExpression.currentValue;\n            }\n            if (showTemplate) {\n                this._maskService.showTemplate = showTemplate.currentValue;\n            }\n            if (clearIfNotMatch) {\n                this._maskService.clearIfNotMatch = clearIfNotMatch.currentValue;\n            }\n            if (validation) {\n                this._maskService.validation = validation.currentValue;\n            }\n            if (separatorLimit) {\n                this._maskService.separatorLimit = separatorLimit.currentValue;\n            }\n            if (allowNegativeNumbers) {\n                this._maskService.allowNegativeNumbers = allowNegativeNumbers.currentValue;\n                if (this._maskService.allowNegativeNumbers) {\n                    this._maskService.maskSpecialCharacters = this._maskService.maskSpecialCharacters.filter((c) => c !== '-');\n                }\n            }\n            if (leadZeroDateTime) {\n                this._maskService.leadZeroDateTime = leadZeroDateTime.currentValue;\n            }\n            this._applyMask();\n        }\n        // tslint:disable-next-line: cyclomatic-complexity\n        validate({ value }) {\n            if (!this._maskService.validation || !this._maskValue) {\n                return null;\n            }\n            if (this._maskService.ipError) {\n                return this._createValidationError(value);\n            }\n            if (this._maskService.cpfCnpjError) {\n                return this._createValidationError(value);\n            }\n            if (this._maskValue.startsWith('separator')) {\n                return null;\n            }\n            if (withoutValidation.includes(this._maskValue)) {\n                return null;\n            }\n            if (this._maskService.clearIfNotMatch) {\n                return null;\n            }\n            if (timeMasks.includes(this._maskValue)) {\n                return this._validateTime(value);\n            }\n            if (value && value.toString().length >= 1) {\n                let counterOfOpt = 0;\n                for (const key in this._maskService.maskAvailablePatterns) {\n                    if (this._maskService.maskAvailablePatterns[key].optional &&\n                        this._maskService.maskAvailablePatterns[key].optional === true) {\n                        if (this._maskValue.indexOf(key) !== this._maskValue.lastIndexOf(key)) {\n                            const opt = this._maskValue\n                                .split('')\n                                .filter((i) => i === key)\n                                .join('');\n                            counterOfOpt += opt.length;\n                        }\n                        else if (this._maskValue.indexOf(key) !== -1) {\n                            counterOfOpt++;\n                        }\n                        if (this._maskValue.indexOf(key) !== -1 && value.toString().length >= this._maskValue.indexOf(key)) {\n                            return null;\n                        }\n                        if (counterOfOpt === this._maskValue.length) {\n                            return null;\n                        }\n                    }\n                }\n                if (this._maskValue.indexOf('{') === 1 &&\n                    value.toString().length === this._maskValue.length + Number(this._maskValue.split('{')[1].split('}')[0]) - 4) {\n                    return null;\n                }\n                if (this._maskValue.indexOf('*') === 1 || this._maskValue.indexOf('?') === 1) {\n                    return null;\n                }\n                else if ((this._maskValue.indexOf('*') > 1 && value.toString().length < this._maskValue.indexOf('*')) ||\n                    (this._maskValue.indexOf('?') > 1 && value.toString().length < this._maskValue.indexOf('?')) ||\n                    this._maskValue.indexOf('{') === 1) {\n                    return this._createValidationError(value);\n                }\n                if (this._maskValue.indexOf('*') === -1 || this._maskValue.indexOf('?') === -1) {\n                    const length = this._maskService.dropSpecialCharacters\n                        ? this._maskValue.length - this._maskService.checkSpecialCharAmount(this._maskValue) - counterOfOpt\n                        : this._maskValue.length - counterOfOpt;\n                    if (value.toString().length < length) {\n                        return this._createValidationError(value);\n                    }\n                }\n            }\n            return null;\n        }\n        onPaste() {\n            this._justPasted = true;\n        }\n        onInput(e) {\n            const el = e.target;\n            this._inputValue = el.value;\n            this._setMask();\n            if (!this._maskValue) {\n                this.onChange(el.value);\n                return;\n            }\n            const position = el.selectionStart === 1\n                ? el.selectionStart + this._maskService.prefix.length\n                : el.selectionStart;\n            let caretShift = 0;\n            let backspaceShift = false;\n            this._maskService.applyValueChanges(position, this._justPasted, this._code === 'Backspace', (shift, _backspaceShift) => {\n                this._justPasted = false;\n                caretShift = shift;\n                backspaceShift = _backspaceShift;\n            });\n            // only set the selection if the element is active\n            if (this.document.activeElement !== el) {\n                return;\n            }\n            this._position = this._position === 1 && this._inputValue.length === 1 ? null : this._position;\n            let positionToApply = this._position\n                ? this._inputValue.length + position + caretShift\n                : position + (this._code === 'Backspace' && !backspaceShift ? 0 : caretShift);\n            if (positionToApply > this._getActualInputLength()) {\n                positionToApply = this._getActualInputLength();\n            }\n            el.setSelectionRange(positionToApply, positionToApply);\n            this._position = null;\n        }\n        onBlur() {\n            if (this._maskValue) {\n                this._maskService.clearIfNotMatchFn();\n            }\n            this.onTouch();\n        }\n        onFocus(e) {\n            if (!this._maskValue) {\n                return;\n            }\n            const el = e.target;\n            const posStart = 0;\n            const posEnd = 0;\n            if (el !== null &&\n                el.selectionStart !== null &&\n                el.selectionStart === el.selectionEnd &&\n                el.selectionStart > this._maskService.prefix.length &&\n                // tslint:disable-next-line\n                e.keyCode !== 38) {\n                if (this._maskService.showMaskTyped) {\n                    // We are showing the mask in the input\n                    this._maskService.maskIsShown = this._maskService.showMaskInInput();\n                    if (el.setSelectionRange && this._maskService.prefix + this._maskService.maskIsShown === el.value) {\n                        // the input ONLY contains the mask, so position the cursor at the start\n                        el.focus();\n                        el.setSelectionRange(posStart, posEnd);\n                    }\n                    else {\n                        // the input contains some characters already\n                        if (el.selectionStart > this._maskService.actualValue.length) {\n                            // if the user clicked beyond our value's length, position the cursor at the end of our value\n                            el.setSelectionRange(this._maskService.actualValue.length, this._maskService.actualValue.length);\n                        }\n                    }\n                }\n            }\n            const nextValue = !el.value || el.value === this._maskService.prefix\n                ? this._maskService.prefix + this._maskService.maskIsShown\n                : el.value;\n            /** Fix of cursor position jumping to end in most browsers no matter where cursor is inserted onFocus */\n            if (el.value !== nextValue) {\n                el.value = nextValue;\n            }\n            /** fix of cursor position with prefix when mouse click occur */\n            if ((el.selectionStart || el.selectionEnd) <= this._maskService.prefix.length) {\n                el.selectionStart = this._maskService.prefix.length;\n                return;\n            }\n            /** select only inserted text */\n            if (el.selectionEnd > this._getActualInputLength()) {\n                el.selectionEnd = this._getActualInputLength();\n            }\n        }\n        // tslint:disable-next-line: cyclomatic-complexity\n        onKeyDown(e) {\n            var _a;\n            if (!this._maskValue) {\n                return;\n            }\n            this._code = e.code ? e.code : e.key;\n            const el = e.target;\n            this._inputValue = el.value;\n            this._setMask();\n            if (e.keyCode === 38) {\n                e.preventDefault();\n            }\n            if (e.keyCode === 37 || e.keyCode === 8 || e.keyCode === 46) {\n                if (e.keyCode === 8 && el.value.length === 0) {\n                    el.selectionStart = el.selectionEnd;\n                }\n                if (e.keyCode === 8 && el.selectionStart !== 0) {\n                    // If specialChars is false, (shouldn't ever happen) then set to the defaults\n                    this.specialCharacters = ((_a = this.specialCharacters) === null || _a === void 0 ? void 0 : _a.length) ? this.specialCharacters\n                        : this._config.specialCharacters;\n                    if (this.prefix.length > 1 && el.selectionStart <= this.prefix.length) {\n                        el.setSelectionRange(this.prefix.length, this.prefix.length);\n                    }\n                    else {\n                        if (this._inputValue.length !== el.selectionStart && el.selectionStart !== 1) {\n                            while (this.specialCharacters.includes(this._inputValue[el.selectionStart - 1].toString()) &&\n                                ((this.prefix.length >= 1 && el.selectionStart > this.prefix.length) ||\n                                    this.prefix.length === 0)) {\n                                el.setSelectionRange(el.selectionStart - 1, el.selectionStart - 1);\n                            }\n                        }\n                        this.suffixCheckOnPressDelete(e.keyCode, el);\n                    }\n                }\n                this.suffixCheckOnPressDelete(e.keyCode, el);\n                if (this._maskService.prefix.length &&\n                    el.selectionStart <= this._maskService.prefix.length &&\n                    el.selectionEnd <= this._maskService.prefix.length) {\n                    e.preventDefault();\n                }\n                const cursorStart = el.selectionStart;\n                // this.onFocus(e);\n                if (e.keyCode === 8 &&\n                    !el.readOnly &&\n                    cursorStart === 0 &&\n                    el.selectionEnd === el.value.length &&\n                    el.value.length !== 0) {\n                    this._position = this._maskService.prefix ? this._maskService.prefix.length : 0;\n                    this._maskService.applyMask(this._maskService.prefix, this._maskService.maskExpression, this._position);\n                }\n            }\n            if (!!this.suffix &&\n                this.suffix.length > 1 &&\n                this._inputValue.length - this.suffix.length < el.selectionStart) {\n                el.setSelectionRange(this._inputValue.length - this.suffix.length, this._inputValue.length);\n            }\n            else if ((e.keyCode === 65 && e.ctrlKey === true) || // Ctrl+ A\n                (e.keyCode === 65 && e.metaKey === true) // Cmd + A (Mac)\n            ) {\n                el.setSelectionRange(0, this._getActualInputLength());\n                e.preventDefault();\n            }\n            this._maskService.selStart = el.selectionStart;\n            this._maskService.selEnd = el.selectionEnd;\n        }\n        /** It writes the value in the input */\n        writeValue(inputValue) {\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[/* __awaiter */ \"b\"])(this, void 0, void 0, function* () {\n                if (typeof inputValue === 'object' && inputValue !== null && 'value' in inputValue) {\n                    if ('disable' in inputValue) {\n                        this.setDisabledState(Boolean(inputValue.disable));\n                    }\n                    inputValue = inputValue.value;\n                }\n                if (inputValue === undefined) {\n                    inputValue = '';\n                }\n                if (typeof inputValue === 'number') {\n                    inputValue = String(inputValue);\n                    inputValue = this.decimalMarker !== '.' ? inputValue.replace('.', this.decimalMarker) : inputValue;\n                    this._maskService.isNumberValue = true;\n                }\n                if ((inputValue && this._maskService.maskExpression) ||\n                    (this._maskService.maskExpression && (this._maskService.prefix || this._maskService.showMaskTyped))) {\n                    // Let the service we know we are writing value so that triggering onChange function wont happen during applyMask\n                    this._maskService.writingValue = true;\n                    this._maskService.formElementProperty = [\n                        'value',\n                        this._maskService.applyMask(inputValue, this._maskService.maskExpression),\n                    ];\n                    // Let the service know we've finished writing value\n                    this._maskService.writingValue = false;\n                }\n                else {\n                    this._maskService.formElementProperty = ['value', inputValue];\n                }\n                this._inputValue = inputValue;\n            });\n        }\n        registerOnChange(fn) {\n            this.onChange = fn;\n            this._maskService.onChange = this.onChange;\n        }\n        registerOnTouched(fn) {\n            this.onTouch = fn;\n        }\n        suffixCheckOnPressDelete(keyCode, el) {\n            if (keyCode === 46 && this.suffix.length > 0) {\n                if (this._inputValue.length - this.suffix.length <= el.selectionStart) {\n                    el.setSelectionRange(this._inputValue.length - this.suffix.length, this._inputValue.length);\n                }\n            }\n            if (keyCode === 8) {\n                if (this.suffix.length > 1 && this._inputValue.length - this.suffix.length < el.selectionStart) {\n                    el.setSelectionRange(this._inputValue.length - this.suffix.length, this._inputValue.length);\n                }\n                if (this.suffix.length === 1 && this._inputValue.length === el.selectionStart) {\n                    el.setSelectionRange(el.selectionStart - 1, el.selectionStart - 1);\n                }\n            }\n        }\n        /** It disables the input element */\n        setDisabledState(isDisabled) {\n            this._maskService.formElementProperty = ['disabled', isDisabled];\n        }\n        _repeatPatternSymbols(maskExp) {\n            return ((maskExp.match(/{[0-9]+}/) &&\n                maskExp.split('').reduce((accum, currval, index) => {\n                    this._start = currval === '{' ? index : this._start;\n                    if (currval !== '}') {\n                        return this._maskService._findSpecialChar(currval) ? accum + currval : accum;\n                    }\n                    this._end = index;\n                    const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n                    const replaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n                    return accum + replaceWith;\n                }, '')) ||\n                maskExp);\n        }\n        // tslint:disable-next-line:no-any\n        _applyMask() {\n            this._maskService.maskExpression = this._repeatPatternSymbols(this._maskValue || '');\n            this._maskService.formElementProperty = [\n                'value',\n                this._maskService.applyMask(this._inputValue, this._maskService.maskExpression),\n            ];\n        }\n        _validateTime(value) {\n            const rowMaskLen = this._maskValue.split('').filter((s) => s !== ':').length;\n            if (value === null || value.length === 0) {\n                return null; // Don't validate empty values to allow for optional form control\n            }\n            if ((+value[value.length - 1] === 0 && value.length < rowMaskLen) || value.length <= rowMaskLen - 2) {\n                return this._createValidationError(value);\n            }\n            return null;\n        }\n        _getActualInputLength() {\n            return (this._maskService.actualValue.length || this._maskService.actualValue.length + this._maskService.prefix.length);\n        }\n        _createValidationError(actualValue) {\n            return {\n                mask: {\n                    requiredMask: this._maskValue,\n                    actualValue,\n                },\n            };\n        }\n        _setMask() {\n            if (this._maskExpressionArray.length > 0) {\n                this._maskExpressionArray.some((mask) => {\n                    const test = this._maskService.removeMask(this._inputValue).length <= this._maskService.removeMask(mask).length;\n                    if (this._inputValue && test) {\n                        this._maskValue = mask;\n                        this.maskExpression = mask;\n                        this._maskService.maskExpression = mask;\n                        return test;\n                    }\n                    else {\n                        this._maskValue = this._maskExpressionArray[this._maskExpressionArray.length - 1];\n                        this.maskExpression = this._maskExpressionArray[this._maskExpressionArray.length - 1];\n                        this._maskService.maskExpression = this._maskExpressionArray[this._maskExpressionArray.length - 1];\n                    }\n                });\n            }\n        }\n    }\n    MaskDirective.ɵfac = function MaskDirective_Factory(t) { return new (t || MaskDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_common__WEBPACK_IMPORTED_MODULE_3__[/* DOCUMENT */ \"d\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](MaskService), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](config)); };\n    MaskDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Gb\"]({ type: MaskDirective, selectors: [[\"input\", \"mask\", \"\"], [\"textarea\", \"mask\", \"\"]], hostBindings: function MaskDirective_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"bc\"](\"paste\", function MaskDirective_paste_HostBindingHandler() { return ctx.onPaste(); })(\"input\", function MaskDirective_input_HostBindingHandler($event) { return ctx.onInput($event); })(\"blur\", function MaskDirective_blur_HostBindingHandler() { return ctx.onBlur(); })(\"click\", function MaskDirective_click_HostBindingHandler($event) { return ctx.onFocus($event); })(\"keydown\", function MaskDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });\n            }\n        }, inputs: { maskExpression: [\"mask\", \"maskExpression\"], specialCharacters: \"specialCharacters\", patterns: \"patterns\", prefix: \"prefix\", suffix: \"suffix\", thousandSeparator: \"thousandSeparator\", decimalMarker: \"decimalMarker\", dropSpecialCharacters: \"dropSpecialCharacters\", hiddenInput: \"hiddenInput\", showMaskTyped: \"showMaskTyped\", placeHolderCharacter: \"placeHolderCharacter\", shownMaskExpression: \"shownMaskExpression\", showTemplate: \"showTemplate\", clearIfNotMatch: \"clearIfNotMatch\", validation: \"validation\", separatorLimit: \"separatorLimit\", allowNegativeNumbers: \"allowNegativeNumbers\", leadZeroDateTime: \"leadZeroDateTime\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵProvidersFeature */ \"xb\"]([\n                {\n                    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__[/* NG_VALUE_ACCESSOR */ \"h\"],\n                    useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* forwardRef */ \"T\"])(() => MaskDirective),\n                    multi: true\n                },\n                {\n                    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__[/* NG_VALIDATORS */ \"g\"],\n                    useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* forwardRef */ \"T\"])(() => MaskDirective),\n                    multi: true\n                },\n                MaskService,\n            ]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵNgOnChangesFeature */ \"wb\"]] });\n    return MaskDirective;\n})();\nlet MaskPipe = /*@__PURE__*/ (() => {\n    class MaskPipe {\n        constructor(_maskService) {\n            this._maskService = _maskService;\n        }\n        transform(value, mask, thousandSeparator = null) {\n            if (!value && typeof value !== 'number') {\n                return '';\n            }\n            if (thousandSeparator) {\n                this._maskService.thousandSeparator = thousandSeparator;\n            }\n            if (typeof mask === 'string') {\n                return this._maskService.applyMask(`${value}`, mask);\n            }\n            return this._maskService.applyMaskWithPattern(`${value}`, mask);\n        }\n    }\n    MaskPipe.ɵfac = function MaskPipe_Factory(t) { return new (t || MaskPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](MaskApplierService)); };\n    MaskPipe.ɵpipe = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefinePipe */ \"Kb\"]({ name: \"mask\", type: MaskPipe, pure: true });\n    return MaskPipe;\n})();\nlet NgxMaskModule = /*@__PURE__*/ (() => {\n    class NgxMaskModule {\n        static forRoot(configValue) {\n            return {\n                ngModule: NgxMaskModule,\n                providers: [\n                    {\n                        provide: NEW_CONFIG,\n                        useValue: configValue,\n                    },\n                    {\n                        provide: INITIAL_CONFIG,\n                        useValue: initialConfig,\n                    },\n                    {\n                        provide: config,\n                        useFactory: _configFactory,\n                        deps: [INITIAL_CONFIG, NEW_CONFIG],\n                    },\n                    MaskApplierService,\n                ],\n            };\n        }\n        static forChild() {\n            return {\n                ngModule: NgxMaskModule,\n            };\n        }\n    }\n    NgxMaskModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineNgModule */ \"Jb\"]({ type: NgxMaskModule });\n    NgxMaskModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjector */ \"Ib\"]({ factory: function NgxMaskModule_Factory(t) { return new (t || NgxMaskModule)(); } });\n    return NgxMaskModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵsetNgModuleScope */ \"Ac\"](NgxMaskModule, { declarations: [MaskDirective, MaskPipe], exports: [MaskDirective, MaskPipe] }); })();\n/**\n * @internal\n */\nfunction _configFactory(initConfig, configValue) {\n    return configValue instanceof Function ? Object.assign(Object.assign({}, initConfig), configValue()) : Object.assign(Object.assign({}, initConfig), configValue);\n}\nconst commonjsGlobal = typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n            ? global\n            : typeof self !== 'undefined'\n                ? self\n                : {};\n(function () {\n    if (!commonjsGlobal.KeyboardEvent) {\n        commonjsGlobal.KeyboardEvent = function (_eventType, _init) { };\n    }\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=ngx-mask.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}