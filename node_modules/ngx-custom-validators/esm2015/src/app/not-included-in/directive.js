import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { notIncludedIn } from './validator';
import * as ɵngcc0 from '@angular/core';
const NOT_INCLUDED_IN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NotIncludedInValidator),
    multi: true
};
export class NotIncludedInValidator {
    ngOnInit() {
        this.validator = notIncludedIn(this.notIncludedIn);
    }
    ngOnChanges(changes) {
        for (const key in changes) {
            if (key === 'notIncludedIn') {
                this.validator = notIncludedIn(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
NotIncludedInValidator.ɵfac = function NotIncludedInValidator_Factory(t) { return new (t || NotIncludedInValidator)(); };
NotIncludedInValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NotIncludedInValidator, selectors: [["", "notIncludedIn", "", "formControlName", ""], ["", "notIncludedIn", "", "formControl", ""], ["", "notIncludedIn", "", "ngModel", ""]], inputs: { notIncludedIn: "notIncludedIn" }, features: [ɵngcc0.ɵɵProvidersFeature([NOT_INCLUDED_IN_VALIDATOR]), ɵngcc0.ɵɵNgOnChangesFeature] });
NotIncludedInValidator.propDecorators = {
    notIncludedIn: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NotIncludedInValidator, [{
        type: Directive,
        args: [{
                selector: '[notIncludedIn][formControlName],[notIncludedIn][formControl],[notIncludedIn][ngModel]',
                providers: [NOT_INCLUDED_IN_VALIDATOR]
            }]
    }], null, { notIncludedIn: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0aXZlLmpzIiwic291cmNlcyI6WyJkaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFvQyxNQUFNLGVBQWUsQ0FBQztBQUMvRixPQUFPLEVBQUUsYUFBYSxFQUEyQyxNQUFNLGdCQUFnQixDQUFDO0FBRXhGLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxhQUFhLENBQUM7O0FBRTVDLE1BQU0seUJBQXlCLEdBQVE7QUFDdkMsSUFBRSxPQUFPLEVBQUUsYUFBYTtBQUN4QixJQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsc0JBQXNCLENBQUM7QUFDdkQsSUFBRSxLQUFLLEVBQUUsSUFBSTtBQUNiLENBQUMsQ0FBQztBQU1GLE1BQU0sT0FBTyxzQkFBc0I7QUFBRyxJQU1wQyxRQUFRO0FBQ1YsUUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkQsSUFBRSxDQUFDO0FBQ0gsSUFDRSxXQUFXLENBQUMsT0FBc0I7QUFDcEMsUUFBSSxLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUMvQixZQUFNLElBQUksR0FBRyxLQUFLLGVBQWUsRUFBRTtBQUNuQyxnQkFBUSxJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDbEUsZ0JBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQzNCLG9CQUFVLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUMxQixpQkFBUztBQUNULGFBQU87QUFDUCxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDRSxRQUFRLENBQUMsQ0FBa0I7QUFBSSxRQUM3QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0IsSUFBRSxDQUFDO0FBQ0gsSUFDRSx5QkFBeUIsQ0FBQyxFQUFjO0FBQUksUUFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDdkIsSUFBRSxDQUFDO0FBQ0g7a0RBaENDLFNBQVMsU0FBQyxrQkFDVCxRQUFRLEVBQUU7OERBQXdGLGtCQUNsRyxTQUFTLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQyxjQUN2Qyx5UEFDSTtBQUFDO0FBQTBDLDRCQUM3QyxLQUFLO0FBQUk7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgZm9yd2FyZFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgbm90SW5jbHVkZWRJbiB9IGZyb20gJy4vdmFsaWRhdG9yJztcblxuY29uc3QgTk9UX0lOQ0xVREVEX0lOX1ZBTElEQVRPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOb3RJbmNsdWRlZEluVmFsaWRhdG9yKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tub3RJbmNsdWRlZEluXVtmb3JtQ29udHJvbE5hbWVdLFtub3RJbmNsdWRlZEluXVtmb3JtQ29udHJvbF0sW25vdEluY2x1ZGVkSW5dW25nTW9kZWxdJyxcbiAgcHJvdmlkZXJzOiBbTk9UX0lOQ0xVREVEX0lOX1ZBTElEQVRPUl1cbn0pXG5leHBvcnQgY2xhc3MgTm90SW5jbHVkZWRJblZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBub3RJbmNsdWRlZEluOiBBcnJheTxhbnk+O1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IG5vdEluY2x1ZGVkSW4odGhpcy5ub3RJbmNsdWRlZEluKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbm90SW5jbHVkZWRJbicpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBub3RJbmNsdWRlZEluKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG4iXX0=